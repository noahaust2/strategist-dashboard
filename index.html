<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Autonomous Agent Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<style>
:root {
  --bg-primary: #0a0a0f;
  --bg-secondary: #12121a;
  --bg-tertiary: #1a1a28;
  --bg-card: #15151f;
  --border-subtle: #2a2a3a;
  --border-active: #3a3a5a;
  --text-primary: #e8e8f0;
  --text-secondary: #9898b0;
  --text-muted: #606080;
  --accent-blue: #4a9eff;
  --accent-green: #34d399;
  --accent-amber: #f59e0b;
  --accent-cyan: #22d3ee;
  --accent-rose: #f472b6;
  --accent-violet: #a78bfa;
  --accent-purple: #8b5cf6;
  --health-green: #22c55e;
  --health-yellow: #eab308;
  --health-red: #ef4444;
  --sidebar-width: 380px;
  --glow-blue: 0 0 20px rgba(74,158,255,0.3);
  --glow-green: 0 0 20px rgba(52,211,153,0.3);
  --glow-amber: 0 0 20px rgba(245,158,11,0.3);
  --glow-purple: 0 0 20px rgba(139,92,246,0.3);
  --font-mono: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: var(--font-sans);
  -webkit-font-smoothing: antialiased;
}

#canvas-container {
  position: fixed; inset: 0;
  z-index: 1;
}

canvas#bg-canvas {
  position: absolute; inset: 0;
  width: 100%; height: 100%;
}

svg#main-viz {
  position: absolute; inset: 0;
  width: 100%; height: 100%;
}

/* Health pulse animation (used by HUD dot) */
@keyframes healthPulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(0.85); }
}

/* Zoom level indicator */
#zoom-indicator {
  position: fixed; bottom: 20px; right: 24px;
  z-index: 100;
  font-size: 11px; color: var(--text-muted);
  font-family: var(--font-mono);
  pointer-events: none;
  opacity: 0; transition: opacity 0.5s;
  text-shadow: 0 0 10px rgba(0,0,0,0.8);
}
#zoom-indicator.visible { opacity: 1; }

/* Sidebar */
#sidebar {
  position: fixed; top: 0; right: 0;
  width: var(--sidebar-width);
  height: 100vh;
  z-index: 200;
  background: var(--bg-secondary);
  border-left: 1px solid var(--border-subtle);
  transform: translateX(100%);
  transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex; flex-direction: column;
  overflow: hidden;
}

#sidebar.open { transform: translateX(0); }

/* Sidebar tab strip */
#sidebar-tabs {
  position: fixed;
  top: 50%; right: 0;
  transform: translateY(-50%);
  z-index: 201;
  display: flex; flex-direction: column; gap: 2px;
}

#sidebar.open ~ #sidebar-tabs { right: var(--sidebar-width); }

.sidebar-tab {
  width: 36px; height: 44px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-subtle);
  border-right: none;
  border-radius: 8px 0 0 8px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  color: var(--text-muted);
  font-size: 16px;
  transition: all 0.2s;
}

.sidebar-tab:hover { background: var(--bg-card); color: var(--text-secondary); }
.sidebar-tab.active { background: var(--bg-secondary); color: var(--accent-blue); border-color: var(--border-active); }

/* Sidebar panels */
.sidebar-panel {
  display: none;
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.sidebar-panel.active { display: block; }

.sidebar-panel::-webkit-scrollbar { width: 4px; }
.sidebar-panel::-webkit-scrollbar-track { background: transparent; }
.sidebar-panel::-webkit-scrollbar-thumb { background: var(--border-subtle); border-radius: 2px; }

/* Sidebar header */
.panel-header {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
  margin-bottom: 16px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border-subtle);
}

/* Current task card */
.task-card {
  background: var(--bg-card);
  border: 1px solid var(--border-subtle);
  border-radius: 10px;
  padding: 16px;
  margin-bottom: 16px;
}

.task-card .goal-badge {
  display: inline-block;
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  padding: 3px 8px;
  border-radius: 4px;
  margin-bottom: 8px;
}

.task-card .task-name {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-primary);
  margin-bottom: 6px;
  line-height: 1.4;
}

.task-card .task-status {
  font-size: 12px;
  color: var(--text-secondary);
  font-family: var(--font-mono);
}

/* Key numbers grid */
.numbers-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-bottom: 20px;
}

.number-cell {
  background: var(--bg-card);
  border: 1px solid var(--border-subtle);
  border-radius: 8px;
  padding: 12px;
  text-align: center;
}

.number-cell .value {
  font-size: 22px;
  font-weight: 700;
  font-family: var(--font-mono);
  color: var(--text-primary);
  line-height: 1;
  margin-bottom: 4px;
}

.number-cell .label {
  font-size: 10px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

/* Goal progress bars */
.goal-progress {
  margin-bottom: 16px;
}

.goal-progress-item {
  margin-bottom: 12px;
}

.goal-progress-item .goal-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 5px;
}

.goal-progress-item .goal-name {
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: 500;
}

.goal-progress-item .goal-pct {
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--font-mono);
}

.progress-track {
  width: 100%;
  height: 6px;
  background: var(--bg-primary);
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Allocation bar */
.allocation-bar {
  display: flex;
  height: 28px;
  border-radius: 6px;
  overflow: hidden;
  margin-bottom: 6px;
}

.alloc-segment {
  transition: width 0.5s ease;
  position: relative;
}

.alloc-legend {
  display: flex; flex-wrap: wrap; gap: 10px;
  margin-bottom: 16px;
}

.alloc-legend-item {
  display: flex; align-items: center; gap: 5px;
  font-size: 11px; color: var(--text-secondary);
}

.alloc-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
}

/* Opportunities list */
.opportunity-item {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 10px 0;
  border-bottom: 1px solid var(--border-subtle);
}

.opportunity-item:last-child { border-bottom: none; }

.opp-badge {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 2px 6px;
  border-radius: 3px;
  white-space: nowrap;
  margin-top: 2px;
}

.opp-badge.pending { background: rgba(245,158,11,0.15); color: var(--accent-amber); }
.opp-badge.approved { background: rgba(34,211,153,0.15); color: var(--accent-green); }
.opp-badge.rejected { background: rgba(239,68,68,0.15); color: var(--health-red); }

.opp-text {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.4;
}

/* Log entries */
.log-entry {
  padding: 10px 0;
  border-bottom: 1px solid var(--border-subtle);
}

.log-entry:last-child { border-bottom: none; }

.log-date {
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  margin-bottom: 4px;
}

.log-text {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.5;
}

/* Alerts */
.alert-item {
  background: rgba(245,158,11,0.08);
  border: 1px solid rgba(245,158,11,0.2);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 10px;
}

.alert-item.critical {
  background: rgba(239,68,68,0.08);
  border-color: rgba(239,68,68,0.2);
}

.alert-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--accent-amber);
  margin-bottom: 4px;
}

.alert-item.critical .alert-title { color: var(--health-red); }

.alert-desc {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.4;
}

/* Raw files */
.raw-file {
  margin-bottom: 12px;
}

.raw-file summary {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 8px 0;
  list-style: none;
  display: flex; align-items: center; gap: 6px;
}

.raw-file summary::before {
  content: '\25B6';
  font-size: 8px;
  transition: transform 0.2s;
}

.raw-file[open] summary::before { transform: rotate(90deg); }

.raw-file-content {
  background: var(--bg-primary);
  border: 1px solid var(--border-subtle);
  border-radius: 6px;
  padding: 12px;
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.5;
  max-height: 300px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}

/* Tooltip */
#tooltip {
  position: fixed;
  z-index: 500;
  background: var(--bg-card);
  border: 1px solid var(--border-active);
  border-radius: 8px;
  padding: 12px 14px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  max-width: 280px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}

#tooltip.visible { opacity: 1; }

#tooltip .tt-message {
  font-size: 12px;
  color: var(--text-primary);
  line-height: 1.4;
  margin-bottom: 6px;
}

#tooltip .tt-meta {
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-mono);
}

#tooltip .tt-stats {
  display: flex; gap: 10px;
  margin-top: 6px;
}

#tooltip .tt-stat {
  font-size: 10px;
  font-family: var(--font-mono);
}

#tooltip .tt-stat.add { color: var(--accent-green); }
#tooltip .tt-stat.del { color: var(--accent-rose); }
#tooltip .tt-stat.files { color: var(--accent-cyan); }

/* Connection status (inside HUD) */
#connection-status {
  display: flex; align-items: center; gap: 5px;
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  margin-left: 12px;
  flex-shrink: 0;
}

#conn-dot {
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--health-green);
}

#conn-dot.disconnected { background: var(--health-red); }
#conn-dot.connecting { background: var(--health-yellow); animation: healthPulse 1s ease-in-out infinite; }

/* HUD Bar — minimal floating strip */
#hud-bar {
  position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
  z-index: 150;
  height: 36px;
  display: flex; align-items: center;
  padding: 0 16px;
  background: rgba(10, 10, 15, 0.5);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid rgba(42, 42, 58, 0.3);
  border-radius: 20px;
  gap: 14px;
  width: auto;
  max-width: 600px;
}

#hud-health {
  display: flex; align-items: center; gap: 6px;
}

#hud-health .hud-dot {
  width: 10px; height: 10px;
  border-radius: 50%;
  background: var(--health-green);
  box-shadow: 0 0 10px rgba(34,197,94,0.5);
  animation: healthPulse 2s ease-in-out infinite;
  flex-shrink: 0;
}

#hud-health .hud-dot.yellow { background: var(--health-yellow); box-shadow: 0 0 10px rgba(234,179,8,0.5); }
#hud-health .hud-dot.red { background: var(--health-red); box-shadow: 0 0 10px rgba(239,68,68,0.5); }

#hud-health .hud-status-text {
  font-size: 10px;
  color: var(--text-muted);
  font-weight: 500;
  white-space: nowrap;
  max-width: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-width 0.3s, opacity 0.3s;
}

#hud-bar:hover #hud-health .hud-status-text {
  max-width: 200px;
  opacity: 1;
}

#hud-growth {
  display: flex; align-items: center; gap: 4px;
}

#hud-sparkline {
  opacity: 0.7;
}

.hud-growth-label {
  font-size: 9px;
  color: var(--text-muted);
  font-family: var(--font-mono);
  white-space: nowrap;
  max-width: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-width 0.3s, opacity 0.3s;
}

#hud-bar:hover .hud-growth-label {
  max-width: 80px;
  opacity: 1;
}

#hud-task {
  display: flex; align-items: center; gap: 8px;
  overflow: hidden;
  max-width: 0;
  opacity: 0;
  transition: max-width 0.4s ease, opacity 0.3s;
}

#hud-bar:hover #hud-task {
  max-width: 400px;
  opacity: 1;
}

.hud-goal-badge {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  padding: 3px 10px;
  border-radius: 4px;
  white-space: nowrap;
  flex-shrink: 0;
  background: rgba(74,158,255,0.15);
  color: var(--accent-blue);
}

.hud-task-name {
  font-size: 13px;
  color: var(--text-primary);
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.hud-task-status {
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--font-mono);
  white-space: nowrap;
  flex-shrink: 0;
}

#hud-metrics {
  display: flex; align-items: center; gap: 12px;
  max-width: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-width 0.4s ease, opacity 0.3s;
}

#hud-bar:hover #hud-metrics {
  max-width: 300px;
  opacity: 1;
}

.hud-metric {
  display: flex; flex-direction: column; align-items: center; gap: 1px;
}

.hud-metric-value {
  font-size: 14px;
  font-weight: 700;
  font-family: var(--font-mono);
  color: var(--text-primary);
  line-height: 1;
}

.hud-metric-label {
  font-size: 9px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Activity Feed — hidden (info available in sidebar Logs tab) */
#activity-feed {
  display: none;
}

#activity-feed.collapsed {
  max-height: 36px;
}

#feed-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 14px;
  border-bottom: 1px solid var(--border-subtle);
  cursor: pointer;
  user-select: none;
}

.feed-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--text-muted);
  display: flex; align-items: center; gap: 6px;
}

.feed-count {
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  opacity: 0.6;
}

.feed-toggle {
  font-size: 10px;
  color: var(--text-muted);
  transition: transform 0.3s;
}

#activity-feed.collapsed .feed-toggle {
  transform: rotate(180deg);
}

#feed-entries {
  max-height: 276px;
  overflow-y: auto;
  padding: 4px 0;
}

#feed-entries::-webkit-scrollbar { width: 3px; }
#feed-entries::-webkit-scrollbar-track { background: transparent; }
#feed-entries::-webkit-scrollbar-thumb { background: var(--border-subtle); border-radius: 2px; }

.feed-entry {
  display: flex; align-items: flex-start; gap: 8px;
  padding: 5px 14px;
  animation: feedSlideIn 0.3s ease-out;
}

.feed-entry .feed-dot {
  width: 6px; height: 6px;
  border-radius: 50%;
  margin-top: 5px;
  flex-shrink: 0;
}

.feed-entry .feed-time {
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  white-space: nowrap;
  min-width: 52px;
  flex-shrink: 0;
}

.feed-entry .feed-msg {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

@keyframes feedSlideIn {
  from { opacity: 0; transform: translateY(6px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Context Meter (HUD) */
#hud-context {
  display: flex; align-items: center; gap: 8px;
  min-width: 140px;
  flex-shrink: 0;
}

.context-bar {
  display: flex;
  width: 100px; height: 8px;
  border-radius: 4px;
  overflow: hidden;
  background: var(--bg-primary);
  border: 1px solid var(--border-subtle);
}

.ctx-segment { height: 100%; transition: width 0.6s ease; }
.ctx-system { background: var(--accent-cyan); }
.ctx-conversation { background: var(--accent-blue); }
.ctx-tools { background: var(--accent-amber); }
.ctx-thinking { background: var(--accent-purple); }

.context-label {
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  white-space: nowrap;
}

/* Agent Tree Nodes */
.agent-node-bg { transition: all 0.3s ease; }
.agent-node-ring { fill: none; stroke-width: 2; transition: all 0.3s ease; }

.agent-node-label {
  font-family: var(--font-sans);
  font-weight: 600;
  text-anchor: middle;
  pointer-events: none;
}

.agent-node-action {
  font-family: var(--font-mono);
  font-size: 10px;
  text-anchor: middle;
  pointer-events: none;
}

.agent-node-tool-badge {
  font-family: var(--font-mono);
  font-size: 9px;
  font-weight: 600;
  text-anchor: middle;
}

.agent-link-path { stroke-width: 2; fill: none; transition: stroke 0.3s; }
.agent-data-particle { pointer-events: none; }

/* Agent node hover detail popup */
#agent-detail {
  position: fixed;
  z-index: 300;
  width: 260px;
  background: rgba(10, 10, 15, 0.92);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--border-active);
  border-radius: 12px;
  padding: 14px 16px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  display: flex; flex-direction: column; gap: 8px;
}

#agent-detail.visible { opacity: 1; }

#agent-detail-name {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

#agent-detail-status {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  padding: 2px 8px;
  border-radius: 4px;
  display: inline-block;
  width: fit-content;
}

#agent-detail-goal {
  font-size: 11px;
  color: var(--accent-amber);
}

#agent-detail-tool {
  font-size: 12px;
  font-family: var(--font-mono);
  color: var(--accent-cyan);
}

#agent-detail-action {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.4;
}

#agent-detail-model {
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-mono);
}

#agent-detail-tokens {
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  border-top: 1px solid var(--border-subtle);
  padding-top: 6px;
}

/* Phase Indicator */
.phase-track {
  display: flex; gap: 2px;
  margin-bottom: 16px;
  background: var(--bg-primary);
  border-radius: 6px;
  padding: 4px;
  border: 1px solid var(--border-subtle);
}

.phase-step {
  flex: 1;
  text-align: center;
  padding: 6px 4px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 600;
  font-family: var(--font-mono);
  letter-spacing: 0.05em;
  color: var(--text-muted);
  transition: all 0.3s;
}

.phase-step.done { background: rgba(52,211,153,0.12); color: var(--accent-green); }
.phase-step.active { background: rgba(74,158,255,0.15); color: var(--accent-blue); box-shadow: inset 0 0 10px rgba(74,158,255,0.1); }
.phase-step.pending { opacity: 0.4; }

/* Tool Call Items */
.tool-call-item {
  display: flex; align-items: center; gap: 8px;
  padding: 6px 0;
  border-bottom: 1px solid rgba(42,42,58,0.5);
}
.tool-call-item:last-child { border-bottom: none; }

.tool-agent-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }

.tool-name {
  font-size: 11px;
  font-family: var(--font-mono);
  font-weight: 600;
  color: var(--accent-cyan);
  min-width: 60px;
  flex-shrink: 0;
}

.tool-target {
  font-size: 11px;
  color: var(--text-secondary);
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  flex: 1;
}

.tool-status {
  font-size: 9px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.05em;
  padding: 2px 6px; border-radius: 3px;
  flex-shrink: 0;
}

.tool-status.done { background: rgba(52,211,153,0.12); color: var(--accent-green); }
.tool-status.running { background: rgba(74,158,255,0.12); color: var(--accent-blue); animation: toolPulse 1.5s ease-in-out infinite; }
.tool-status.error { background: rgba(239,68,68,0.12); color: var(--health-red); }

@keyframes toolPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.tool-duration {
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  min-width: 40px; text-align: right;
  flex-shrink: 0;
}

/* Thinking Steps */
.thinking-step {
  display: flex; gap: 10px;
  padding: 8px 0;
  border-bottom: 1px solid rgba(42,42,58,0.5);
}
.thinking-step:last-child { border-bottom: none; }

.thinking-phase {
  font-size: 9px; font-weight: 700;
  font-family: var(--font-mono);
  letter-spacing: 0.05em;
  padding: 2px 6px; border-radius: 3px;
  white-space: nowrap;
  height: fit-content; margin-top: 2px;
  flex-shrink: 0;
}

.thinking-phase.read { background: rgba(34,211,238,0.12); color: var(--accent-cyan); }
.thinking-phase.decide { background: rgba(245,158,11,0.12); color: var(--accent-amber); }
.thinking-phase.execute { background: rgba(74,158,255,0.12); color: var(--accent-blue); }
.thinking-phase.verify { background: rgba(52,211,153,0.12); color: var(--accent-green); }

.thinking-content { flex: 1; }
.thinking-text { font-size: 12px; color: var(--text-secondary); line-height: 1.4; }
.thinking-time { font-size: 10px; font-family: var(--font-mono); color: var(--text-muted); margin-top: 2px; }
.thinking-step.active .thinking-text { color: var(--text-primary); }

/* Agent Cards (Process panel) */
.agent-card {
  background: var(--bg-card);
  border: 1px solid var(--border-subtle);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 10px;
}

.agent-card-header {
  display: flex; align-items: center; gap: 8px;
  margin-bottom: 8px;
}

.agent-card-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.agent-card-name { font-size: 12px; font-weight: 600; color: var(--text-primary); }
.agent-card-status { font-size: 10px; font-family: var(--font-mono); color: var(--text-muted); margin-left: auto; }
.agent-card-action { font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; }
.agent-card-tokens { font-size: 10px; font-family: var(--font-mono); color: var(--text-muted); }

.agent-card-bar {
  height: 4px;
  background: var(--bg-primary);
  border-radius: 2px;
  overflow: hidden; margin-top: 6px;
}

.agent-card-fill { height: 100%; border-radius: 2px; transition: width 0.5s ease; }

/* Context detail (sidebar) */
.context-detail {
  display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;
}

.ctx-legend-item {
  display: flex; align-items: center; gap: 4px;
  font-size: 10px; color: var(--text-muted);
}

.ctx-legend-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }

.context-bar-large {
  display: flex;
  width: 100%; height: 14px;
  border-radius: 6px;
  overflow: hidden;
  background: var(--bg-primary);
  border: 1px solid var(--border-subtle);
  margin-bottom: 6px;
}

.context-pct {
  font-size: 13px; font-weight: 600;
  font-family: var(--font-mono);
  color: var(--text-primary);
  margin-bottom: 4px;
}

/* Mobile */
@media (max-width: 768px) {
  #sidebar { width: 100vw; }
  #sidebar.open ~ #sidebar-tabs { right: 100vw; }
  .numbers-grid { grid-template-columns: 1fr 1fr; gap: 6px; }
  .number-cell .value { font-size: 18px; }
  #hud-bar { padding: 0 12px; gap: 10px; }
  #hud-task .hud-task-name { max-width: 150px; }
  #hud-metrics { gap: 10px; }
  .hud-metric-value { font-size: 12px; }
  #activity-feed { width: calc(100vw - 48px); left: 12px; }
  #mission-status { width: calc(100vw - 48px); left: 12px; }
  #thinking-ticker { width: calc(100vw - 48px); right: 12px; }
  .section-marker { display: none; }
  #legend { flex-wrap: wrap; width: calc(100vw - 48px); margin-bottom: 40px; }
}

/* Mission Status Panel — always visible, left side */
#mission-status {
  display: none;
}

#mission-phase-row {
  display: flex; align-items: center; gap: 12px;
}

#mission-phase-badge {
  font-size: 13px;
  font-weight: 700;
  font-family: var(--font-mono);
  letter-spacing: 0.08em;
  padding: 5px 14px;
  border-radius: 6px;
  text-transform: uppercase;
  white-space: nowrap;
}

#mission-phase-badge.read { background: rgba(34,211,238,0.15); color: var(--accent-cyan); box-shadow: 0 0 12px rgba(34,211,238,0.15); }
#mission-phase-badge.decide { background: rgba(245,158,11,0.15); color: var(--accent-amber); box-shadow: 0 0 12px rgba(245,158,11,0.15); }
#mission-phase-badge.execute { background: rgba(74,158,255,0.15); color: var(--accent-blue); box-shadow: 0 0 12px rgba(74,158,255,0.15); }
#mission-phase-badge.verify { background: rgba(52,211,153,0.15); color: var(--accent-green); box-shadow: 0 0 12px rgba(52,211,153,0.15); }

#mission-phase-label {
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--font-mono);
}

#mission-task-section {
  border-top: 1px solid var(--border-subtle);
  padding-top: 12px;
}

#mission-goal-badge {
  display: inline-block;
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  padding: 2px 8px;
  border-radius: 4px;
  margin-bottom: 6px;
  background: rgba(74,158,255,0.15);
  color: var(--accent-blue);
}

#mission-task-name {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-primary);
  line-height: 1.4;
  margin-bottom: 4px;
}

#mission-task-detail {
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--font-mono);
}

#mission-agents-row {
  display: flex; align-items: center; gap: 8px;
  border-top: 1px solid var(--border-subtle);
  padding-top: 10px;
}

.mission-agent-pip {
  width: 8px; height: 8px;
  border-radius: 50%;
  border: 1.5px solid transparent;
}

.mission-agent-pip.active {
  animation: healthPulse 2s ease-in-out infinite;
}

#mission-agent-count {
  font-size: 11px;
  color: var(--text-secondary);
  font-family: var(--font-mono);
}

#mission-thinking {
  border-top: 1px solid var(--border-subtle);
  padding-top: 10px;
}

#mission-thinking-label {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
  margin-bottom: 6px;
}

#mission-thinking-text {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.4;
  max-height: 40px;
  overflow: hidden;
}

#mission-thinking-time {
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-mono);
  margin-top: 3px;
}

/* Thinking ticker — hidden (info available in sidebar + node hover) */
#thinking-ticker {
  display: none;
}

#thinking-ticker-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 14px;
  border-bottom: 1px solid var(--border-subtle);
  cursor: pointer;
  user-select: none;
}

.ticker-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
}

#thinking-ticker-entries {
  max-height: 160px;
  overflow-y: auto;
  padding: 6px 14px;
}

.ticker-entry {
  display: flex; align-items: flex-start; gap: 8px;
  padding: 4px 0;
  animation: feedSlideIn 0.3s ease-out;
}

.ticker-phase {
  font-size: 8px; font-weight: 700;
  font-family: var(--font-mono);
  letter-spacing: 0.05em;
  padding: 1px 5px; border-radius: 3px;
  white-space: nowrap;
  margin-top: 2px;
  flex-shrink: 0;
}

.ticker-phase.read { background: rgba(34,211,238,0.12); color: var(--accent-cyan); }
.ticker-phase.decide { background: rgba(245,158,11,0.12); color: var(--accent-amber); }
.ticker-phase.execute { background: rgba(74,158,255,0.12); color: var(--accent-blue); }
.ticker-phase.verify { background: rgba(52,211,153,0.12); color: var(--accent-green); }

.ticker-text {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.3;
  flex: 1;
}

.ticker-time {
  font-size: 9px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  white-space: nowrap;
  flex-shrink: 0;
}

/* ── Welcome Guide Overlay ─────────────────────────────── */
#welcome-guide {
  position: fixed; inset: 0;
  z-index: 1000;
  background: rgba(5, 5, 10, 0.92);
  backdrop-filter: blur(8px);
  display: flex; align-items: center; justify-content: center;
  transition: opacity 0.4s;
}

#welcome-guide.hidden { opacity: 0; pointer-events: none; }

#guide-content {
  max-width: 680px;
  padding: 40px;
}

#guide-content h1 {
  font-size: 22px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 8px;
}

#guide-content .guide-subtitle {
  font-size: 13px;
  color: var(--text-muted);
  margin-bottom: 32px;
  line-height: 1.5;
}

.guide-areas {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin-bottom: 32px;
}

.guide-area {
  background: var(--bg-card);
  border: 1px solid var(--border-subtle);
  border-radius: 12px;
  padding: 18px;
}

.guide-area-number {
  display: inline-flex; align-items: center; justify-content: center;
  width: 24px; height: 24px;
  border-radius: 50%;
  font-size: 12px; font-weight: 700;
  font-family: var(--font-mono);
  margin-bottom: 10px;
}

.guide-area-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 6px;
}

.guide-area-desc {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.5;
}

#guide-dismiss {
  display: block;
  margin: 0 auto;
  padding: 10px 32px;
  background: var(--accent-blue);
  color: #fff;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  font-family: var(--font-sans);
  transition: background 0.2s;
}

#guide-dismiss:hover { background: #3a8eef; }

/* Help button (re-open guide) */
#help-btn {
  position: fixed;
  bottom: 20px; left: 50%;
  transform: translateX(-50%);
  z-index: 100;
  width: 28px; height: 28px;
  border-radius: 50%;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-subtle);
  color: var(--text-muted);
  font-size: 13px; font-weight: 700;
  font-family: var(--font-mono);
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  transition: all 0.2s;
}

#help-btn:hover { background: var(--bg-card); color: var(--text-secondary); border-color: var(--border-active); }

/* ── Persistent Legend ─────────────────────────────────── */
#legend {
  display: none;
}

.legend-group {
  display: flex; align-items: center; gap: 6px;
}

.legend-group-title {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--text-muted);
  margin-right: 4px;
}

.legend-item {
  display: flex; align-items: center; gap: 4px;
  font-size: 10px;
  color: var(--text-secondary);
}

.legend-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.legend-line {
  width: 16px; height: 2px;
  border-radius: 1px;
  flex-shrink: 0;
}

.legend-divider {
  width: 1px; height: 16px;
  background: var(--border-subtle);
}

/* ── Section Markers (numbered circles) ────────────────── */
.section-marker {
  display: none;
}

.section-number {
  width: 22px; height: 22px;
  border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 11px; font-weight: 700;
  font-family: var(--font-mono);
  flex-shrink: 0;
}

.section-label {
  font-size: 10px;
  font-weight: 500;
  color: var(--text-muted);
  white-space: nowrap;
  font-family: var(--font-mono);
}

#marker-status {
  top: 62px; left: 28px;
}
#marker-status .section-number {
  background: rgba(34,211,238,0.15); color: var(--accent-cyan);
}

#marker-agents {
  top: 62px; left: 50%;
  transform: translateX(-50%);
}
#marker-agents .section-number {
  background: rgba(74,158,255,0.15); color: var(--accent-blue);
}

#marker-thinking {
  bottom: 228px; right: 28px;
}
#marker-thinking .section-number {
  background: rgba(167,139,250,0.15); color: var(--accent-violet);
}

#marker-goals {
  bottom: 270px; left: 50%;
  transform: translateX(-50%);
}
#marker-goals .section-number {
  background: rgba(52,211,153,0.15); color: var(--accent-green);
}

/* HUD phase indicator */
#hud-phase {
  display: flex; align-items: center; gap: 3px;
  flex-shrink: 0;
}

.hud-phase-step {
  width: 28px; height: 4px;
  border-radius: 2px;
  background: var(--bg-tertiary);
  transition: all 0.3s;
}

.hud-phase-step.done { background: var(--accent-green); opacity: 0.7; }
.hud-phase-step.active { background: var(--accent-blue); box-shadow: 0 0 6px rgba(74,158,255,0.4); }
.hud-phase-step.pending { opacity: 0.3; }

.hud-phase-label {
  font-size: 9px;
  font-weight: 700;
  font-family: var(--font-mono);
  letter-spacing: 0.05em;
  color: var(--accent-blue);
  margin-left: 6px;
  white-space: nowrap;
}

/* Ambient background — now handled by canvas drawBg() for phase/health encoding */
</style>
</head>
<body>

<!-- Welcome Guide (shows on first load) -->
<div id="welcome-guide">
  <div id="guide-content">
    <h1>Autonomous Agent Dashboard</h1>
    <div class="guide-subtitle">
      Real-time visualization of your AI agent system. Hover anything for details. Scroll to zoom.
    </div>
    <div class="guide-areas">
      <div class="guide-area">
        <div class="guide-area-number" style="background:rgba(34,211,238,0.15);color:var(--accent-cyan);">1</div>
        <div class="guide-area-title">Canvas Atmosphere</div>
        <div class="guide-area-desc">
          The <strong>background color</strong> shows the current phase. <strong>Brightness</strong>
          reflects growth — vibrant means learning, dim means stalled.
          A <strong>pulsing ring</strong> shows the system heartbeat.
        </div>
      </div>
      <div class="guide-area">
        <div class="guide-area-number" style="background:rgba(74,158,255,0.15);color:var(--accent-blue);">2</div>
        <div class="guide-area-title">Agent Nodes (center)</div>
        <div class="guide-area-desc">
          <strong>Breathing nodes</strong> = active agents. Size = hierarchy.
          <strong>Coral branches</strong> = knowledge learned.
          <strong>Orbiting letters</strong> = planning documents. Zoom in for details.
        </div>
      </div>
      <div class="guide-area">
        <div class="guide-area-number" style="background:rgba(52,211,153,0.15);color:var(--accent-green);">3</div>
        <div class="guide-area-title">Goal Clusters (outer ring)</div>
        <div class="guide-area-desc">
          Each particle cluster is a <strong>goal</strong>. Particles = commits.
          Brighter particles = recent activity. Dim = stalled.
          <strong>Purple lightning</strong> = daydream connections between goals.
        </div>
      </div>
      <div class="guide-area">
        <div class="guide-area-number" style="background:rgba(167,139,250,0.15);color:var(--accent-violet);">4</div>
        <div class="guide-area-title">HUD Bar (top center)</div>
        <div class="guide-area-desc">
          <strong>Dot</strong> = health. <strong>Steps</strong> = loop phase.
          <strong>Bar</strong> = context window. <strong>Sparkline</strong> = growth trend.
          Hover the HUD to see more details. Click sidebar tabs on the right.
        </div>
      </div>
    </div>
    <button id="guide-dismiss">Got it</button>
  </div>
</div>

<!-- Section Markers (numbered reading flow) -->
<div class="section-marker" id="marker-status">
  <span class="section-number">1</span>
  <span class="section-label">Current Status</span>
</div>
<div class="section-marker" id="marker-agents">
  <span class="section-number">2</span>
  <span class="section-label">Agent Architecture</span>
</div>
<div class="section-marker" id="marker-thinking">
  <span class="section-number">3</span>
  <span class="section-label">Decision Flow</span>
</div>
<div class="section-marker" id="marker-goals">
  <span class="section-number">4</span>
  <span class="section-label">Goal Clusters</span>
</div>

<!-- Legend -->
<div id="legend">
  <div class="legend-group">
    <span class="legend-group-title">Background</span>
    <span class="legend-item"><span class="legend-dot" style="background:var(--accent-cyan)"></span>Read phase</span>
    <span class="legend-item"><span class="legend-dot" style="background:var(--accent-amber)"></span>Decide</span>
    <span class="legend-item"><span class="legend-dot" style="background:var(--accent-blue)"></span>Execute</span>
    <span class="legend-item"><span class="legend-dot" style="background:var(--accent-green)"></span>Verify</span>
  </div>
  <div class="legend-divider"></div>
  <div class="legend-group" id="legend-goals">
    <span class="legend-group-title">Goals (colonies + outlines)</span>
  </div>
  <div class="legend-divider"></div>
  <div class="legend-group">
    <span class="legend-group-title">Signals</span>
    <span class="legend-item" title="Agent node outlines match their assigned goal color">Outline = goal</span>
    <span class="legend-item" title="Rotating purple arc = agent is reading/searching">Scan arc = research</span>
    <span class="legend-item" title="Nodes breathe faster when active, slow when stalled">Breathing = activity</span>
    <span class="legend-item" title="Idle agents fade over time">Opacity = freshness</span>
    <span class="legend-item" title="Nodes drift toward the goal they're working on">Drift = focus</span>
    <span class="legend-item" title="Bigger nodes have used more tokens">Size = workload</span>
  </div>
</div>

<!-- Help button -->
<button id="help-btn" title="How to read this dashboard">?</button>

<div id="canvas-container">
  <canvas id="bg-canvas"></canvas>
  <svg id="main-viz"></svg>
</div>

<div id="hud-bar">
  <div id="hud-health" title="System health — green: healthy, yellow: degraded, red: down">
    <div class="hud-dot" id="hud-health-dot"></div>
    <span class="hud-status-text" id="hud-status-text">Initializing...</span>
  </div>
  <div id="hud-phase" title="Agent loop phase — READ → DECIDE → EXECUTE → VERIFY → REPEAT">
    <div class="hud-phase-step pending" data-phase="read"></div>
    <div class="hud-phase-step pending" data-phase="decide"></div>
    <div class="hud-phase-step pending" data-phase="execute"></div>
    <div class="hud-phase-step pending" data-phase="verify"></div>
    <span class="hud-phase-label" id="hud-phase-label">--</span>
  </div>
  <div id="hud-context" title="Context window usage — system / conversation / tools / thinking tokens">
    <div class="context-bar">
      <div class="ctx-segment ctx-system" id="ctx-system"></div>
      <div class="ctx-segment ctx-conversation" id="ctx-conversation"></div>
      <div class="ctx-segment ctx-tools" id="ctx-tools"></div>
      <div class="ctx-segment ctx-thinking" id="ctx-thinking"></div>
    </div>
    <span class="context-label" id="ctx-label">0K / 200K</span>
  </div>
  <div id="hud-growth" title="Knowledge growth — 14-day learning trend from self-modifications">
    <svg id="hud-sparkline" width="40" height="16" viewBox="0 0 40 16"></svg>
    <span id="hud-growth-label" class="hud-growth-label"></span>
  </div>
  <div id="hud-task">
    <span class="hud-goal-badge" id="hud-goal-badge">Agent</span>
    <span class="hud-task-name" id="hud-task-name">Waiting for status...</span>
    <span class="hud-task-status" id="hud-task-status"></span>
  </div>
  <div id="hud-metrics">
    <div class="hud-metric"><span class="hud-metric-value" id="hud-tasks">0</span><span class="hud-metric-label">Tasks/wk</span></div>
    <div class="hud-metric"><span class="hud-metric-value" id="hud-usage">--</span><span class="hud-metric-label">Tokens today</span></div>
    <div id="connection-status">
      <div id="conn-dot" class="connecting"></div>
      <span id="conn-text">connecting</span>
    </div>
  </div>
</div>

<!-- Mission Status Panel — always visible -->
<div id="mission-status">
  <div id="mission-phase-row">
    <div id="mission-phase-badge" class="execute">EXECUTE</div>
    <span id="mission-phase-label">Agent Loop Phase</span>
  </div>
  <div id="mission-task-section">
    <div id="mission-goal-badge">Agent</div>
    <div id="mission-task-name">Waiting for status...</div>
    <div id="mission-task-detail"></div>
  </div>
  <div id="mission-agents-row">
    <span id="mission-agent-count">0 agents</span>
  </div>
  <div id="mission-thinking">
    <div id="mission-thinking-label">Latest Reasoning</div>
    <div id="mission-thinking-text">No thinking data yet</div>
    <div id="mission-thinking-time"></div>
  </div>
</div>


<div id="zoom-indicator">1.0x</div>

<div id="activity-feed">
  <div id="feed-header">
    <span class="feed-title">Activity <span class="feed-count" id="feed-count">0</span></span>
    <span class="feed-toggle">&#9660;</span>
  </div>
  <div id="feed-entries"></div>
</div>

<div id="tooltip">
  <div class="tt-message"></div>
  <div class="tt-meta"></div>
  <div class="tt-stats">
    <span class="tt-stat add"></span>
    <span class="tt-stat del"></span>
    <span class="tt-stat files"></span>
  </div>
</div>

<!-- Agent node hover detail -->
<div id="agent-detail">
  <div id="agent-detail-name"></div>
  <div id="agent-detail-status"></div>
  <div id="agent-detail-goal"></div>
  <div id="agent-detail-action"></div>
  <div id="agent-detail-tool"></div>
  <div id="agent-detail-model"></div>
  <div id="agent-detail-tokens"></div>
</div>

<!-- Thinking Ticker — always visible, bottom right -->
<div id="thinking-ticker">
  <div id="thinking-ticker-header">
    <span class="ticker-title">Decision Flow</span>
  </div>
  <div id="thinking-ticker-entries"></div>
</div>

<div id="sidebar-tabs">
  <div class="sidebar-tab active" data-panel="process" title="Process &amp; Agents">&#9881;</div>
  <div class="sidebar-tab" data-panel="thinking" title="Thinking">&#9733;</div>
  <div class="sidebar-tab" data-panel="goals" title="Goals">&#9673;</div>
  <div class="sidebar-tab" data-panel="system" title="System Architecture">&#9055;</div>
  <div class="sidebar-tab" data-panel="logs" title="Logs &amp; Alerts">&#9776;</div>
  <div class="sidebar-tab" data-panel="raw" title="Raw Data">&#60;/&#62;</div>
</div>

<div id="sidebar">

  <!-- Process Panel (now default — merged with overview) -->
  <div class="sidebar-panel active" id="panel-process">
    <div class="panel-header">Agent Loop Phase</div>
    <div class="phase-track" id="phase-track">
      <div class="phase-step pending" data-phase="read">READ</div>
      <div class="phase-step pending" data-phase="decide">DECIDE</div>
      <div class="phase-step pending" data-phase="execute">EXEC</div>
      <div class="phase-step pending" data-phase="verify">VERIFY</div>
    </div>

    <div class="panel-header">Context Window</div>
    <div class="context-pct" id="ctx-pct">0%</div>
    <div class="context-bar-large" id="ctx-bar-large">
      <div class="ctx-segment ctx-system" id="ctx-lg-system"></div>
      <div class="ctx-segment ctx-conversation" id="ctx-lg-conversation"></div>
      <div class="ctx-segment ctx-tools" id="ctx-lg-tools"></div>
      <div class="ctx-segment ctx-thinking" id="ctx-lg-thinking"></div>
    </div>
    <div class="context-detail" id="ctx-detail">
      <span class="ctx-legend-item"><span class="ctx-legend-dot" style="background:var(--accent-cyan)"></span>System</span>
      <span class="ctx-legend-item"><span class="ctx-legend-dot" style="background:var(--accent-blue)"></span>Convo</span>
      <span class="ctx-legend-item"><span class="ctx-legend-dot" style="background:var(--accent-amber)"></span>Tools</span>
      <span class="ctx-legend-item"><span class="ctx-legend-dot" style="background:var(--accent-purple)"></span>Think</span>
    </div>

    <div class="panel-header" style="margin-top:16px;">Active Agents</div>
    <div id="agent-cards-container"></div>

    <div class="panel-header" style="margin-top:16px;">Tool Calls</div>
    <div id="tool-calls-container"></div>

    <div class="panel-header" style="margin-top:16px;">Alerts</div>
    <div id="alerts-container">
      <div style="font-size:12px;color:var(--text-muted);">No alerts</div>
    </div>

    <div class="panel-header" style="margin-top:16px;">Heartbeat</div>
    <div id="heartbeat-display" style="font-size:11px;color:var(--text-muted);font-family:var(--font-mono);">Last heartbeat: --</div>
  </div>

  <!-- Thinking Panel -->
  <div class="sidebar-panel" id="panel-thinking">
    <div class="panel-header">Decision Flow</div>
    <div id="thinking-container"></div>
  </div>

  <!-- Goals Panel -->
  <div class="sidebar-panel" id="panel-goals">
    <div class="panel-header">Goal Progress</div>
    <div class="goal-progress" id="goal-progress-container"></div>

    <div class="panel-header">7-Day Allocation</div>
    <div class="allocation-bar" id="allocation-bar"></div>
    <div class="alloc-legend" id="alloc-legend"></div>

    <div class="panel-header" style="margin-top:16px;">Cross-Domain Opportunities</div>
    <div id="opportunities-container">
      <div style="font-size:12px;color:var(--text-muted);">No opportunities detected</div>
    </div>

    <div class="panel-header" style="margin-top:16px;">Daydream Hit Rate</div>
    <div class="number-cell" style="max-width:140px;">
      <div class="value" id="num-daydream">0%</div>
      <div class="label">Cross-Domain Hits</div>
    </div>
  </div>

  <!-- System Architecture Panel -->
  <div class="sidebar-panel" id="panel-system">
    <div class="panel-header">Mission Goals</div>
    <div id="system-goals-container">
      <div style="font-size:12px;color:var(--text-muted);">Loading goals...</div>
    </div>

    <div class="panel-header" style="margin-top:16px;">Assets</div>
    <div id="system-assets-container">
      <div style="font-size:12px;color:var(--text-muted);">Loading assets...</div>
    </div>

    <div class="panel-header" style="margin-top:16px;">Nervous System</div>
    <div id="system-docflow-container">
      <svg id="docflow-svg" width="340" height="220" style="display:block;margin:0 auto;"></svg>
    </div>

    <div class="panel-header" style="margin-top:16px;">Evolution</div>
    <div id="system-evolution-stats" style="display:flex;gap:16px;margin-bottom:12px;">
      <div class="number-cell" style="flex:1;">
        <div class="value" id="synapse-total-count">0</div>
        <div class="label">Self-Mods</div>
      </div>
      <div class="number-cell" style="flex:1;">
        <div class="value" id="synapse-week-count">0</div>
        <div class="label">This Week</div>
      </div>
    </div>
    <div id="system-evolution-timeline"></div>
  </div>

  <!-- Logs Panel -->
  <div class="sidebar-panel" id="panel-logs">
    <div class="panel-header">Recent Log</div>
    <div id="log-container">
      <div style="font-size:12px;color:var(--text-muted);">No log entries</div>
    </div>
  </div>

  <!-- Raw Panel -->
  <div class="sidebar-panel" id="panel-raw">
    <div class="panel-header">Raw Files</div>
    <details class="raw-file">
      <summary>STATE.md</summary>
      <div class="raw-file-content" id="raw-state">Loading...</div>
    </details>
    <details class="raw-file">
      <summary>STRATEGY.md</summary>
      <div class="raw-file-content" id="raw-strategy">Loading...</div>
    </details>
    <details class="raw-file">
      <summary>Security Report</summary>
      <div class="raw-file-content" id="raw-security">Loading...</div>
    </details>
  </div>
</div>

<script>
// ============================================================
// AUTONOMOUS AGENT DASHBOARD - Organic Colony Visualization
// ============================================================

(function() {
  'use strict';

  // ----------------------------------------------------------
  // Configuration & Constants
  // ----------------------------------------------------------
  const PALETTE = {
    blue:  { h: 214, s: 100, base: '#4a9eff', glow: 'rgba(74,158,255,', dim: 'rgba(74,158,255,0.15)' },
    green: { h: 160, s: 76,  base: '#34d399', glow: 'rgba(52,211,153,', dim: 'rgba(52,211,153,0.15)' },
    amber: { h: 38,  s: 92,  base: '#f59e0b', glow: 'rgba(245,158,11,', dim: 'rgba(245,158,11,0.15)' },
    cyan:  { h: 191, s: 82,  base: '#22d3ee', glow: 'rgba(34,211,238,', dim: 'rgba(34,211,238,0.15)' },
    rose:  { h: 330, s: 86,  base: '#f472b6', glow: 'rgba(244,114,182,', dim: 'rgba(244,114,182,0.15)' },
  };
  const PALETTE_KEYS = Object.keys(PALETTE);
  const COMMIT_TYPES = { research: '#a78bfa', skill: '#f59e0b', state: '#6b7280', feat: '#4a9eff', fix: '#ef4444', refactor: '#22d3ee', docs: '#34d399', chore: '#6b7280' };

  // Synapse node colors by commit type (extends COMMIT_TYPES with glow)
  const SYNAPSE_COLORS = {
    feat:     { base: '#4a9eff', glow: 'rgba(74,158,255,' },
    fix:      { base: '#ef4444', glow: 'rgba(239,68,68,' },
    refactor: { base: '#22d3ee', glow: 'rgba(34,211,238,' },
    research: { base: '#a78bfa', glow: 'rgba(167,139,250,' },
    skill:    { base: '#f59e0b', glow: 'rgba(245,158,11,' },
    docs:     { base: '#34d399', glow: 'rgba(52,211,153,' },
    rules:    { base: '#f59e0b', glow: 'rgba(245,158,11,' },
    review:   { base: '#f472b6', glow: 'rgba(244,114,182,' },
    state:    { base: '#6b7280', glow: 'rgba(107,114,128,' },
    strategy: { base: '#4a9eff', glow: 'rgba(74,158,255,' },
    identity: { base: '#a78bfa', glow: 'rgba(167,139,250,' },
    chore:    { base: '#6b7280', glow: 'rgba(107,114,128,' },
    other:    { base: '#8b5cf6', glow: 'rgba(139,92,246,' },
  };
  // Angle offsets for type clustering in synapse tree
  const SYNAPSE_TYPE_ANGLES = {
    feat: 0, fix: Math.PI * 0.25, refactor: Math.PI * 0.5,
    research: Math.PI * 0.75, skill: Math.PI, docs: Math.PI * 1.25,
    rules: Math.PI * 1.5, review: Math.PI * 1.75,
    state: Math.PI * 0.4, strategy: Math.PI * 1.1,
    identity: Math.PI * 1.6, chore: Math.PI * 0.6,
    other: Math.PI * 1.9,
  };

  // ----------------------------------------------------------
  // State
  // ----------------------------------------------------------
  const state = {
    goals: [],
    colonies: new Map(),
    particles: [],
    daydreamLinks: [],
    activeGoal: null,
    activeTask: null,
    health: 'green',
    statusText: 'Initializing...',
    lastHeartbeat: null,
    agentMode: 'active',
    zoom: 1,
    pan: { x: 0, y: 0 },
    width: window.innerWidth,
    height: window.innerHeight,
    sidebarOpen: false,
    activePanel: 'process',
    metrics: { revenue: '$0', views: 0, tasksPerWeek: 0, skills: 0, daydreamHitRate: 0 },
    time: 0,
    mouse: { x: -1000, y: -1000 },
    hoveredParticle: null,
    // Agent tree & process
    agents: new Map(),
    context: { max: 200000, system: 0, conversation: 0, tools: 0, thinking: 0 },
    toolCalls: [],
    thinkingSteps: [],
    agentPhase: 'read',
    dataParticles: [],
    liveConnected: false,
    // Architecture & Synapse Tree
    goalsText: [],          // Full goal text blocks from GOALS.md
    assetsData: {},         // Categorized assets from ASSETS.md
    documents: {},          // Document metadata {name: {exists, mtime, size}}
    synapses: [],           // Learning events [{hash, date, message, type, x, y, parent}]
    synapseSim: null,       // D3 force simulation for synapse layout
    reviewStatus: { sessionsSinceReview: 0, interval: 5 },
    daydreamSparks: [],     // Animated spark effects
  };

  // ----------------------------------------------------------
  // Background Canvas (starfield / ambient)
  // ----------------------------------------------------------
  const bgCanvas = document.getElementById('bg-canvas');
  const bgCtx = bgCanvas.getContext('2d');
  let bgStars = [];

  function initBgCanvas() {
    bgCanvas.width = state.width * devicePixelRatio;
    bgCanvas.height = state.height * devicePixelRatio;
    bgCanvas.style.width = state.width + 'px';
    bgCanvas.style.height = state.height + 'px';
    bgCtx.scale(devicePixelRatio, devicePixelRatio);

    bgStars = [];
    const count = Math.floor((state.width * state.height) / 2000);
    for (let i = 0; i < count; i++) {
      bgStars.push({
        x: Math.random() * state.width,
        y: Math.random() * state.height,
        r: Math.random() * 1.2 + 0.2,
        alpha: Math.random() * 0.4 + 0.05,
        speed: Math.random() * 0.003 + 0.001,
        phase: Math.random() * Math.PI * 2,
      });
    }
  }

  // Phase color map for ambient nebula
  const PHASE_NEBULA = {
    read:    { r: 34, g: 211, b: 238 },  // cyan
    decide:  { r: 245, g: 158, b: 11 },  // amber
    execute: { r: 74, g: 158, b: 255 },  // blue
    verify:  { r: 52, g: 211, b: 153 },  // green
  };

  // Health modifiers for visual mood
  const HEALTH_MOOD = {
    green:  { starBright: 1.0, nebulaIntensity: 1.0, pulseSpeed: 1.0 },
    yellow: { starBright: 0.7, nebulaIntensity: 1.4, pulseSpeed: 1.8 },
    red:    { starBright: 0.4, nebulaIntensity: 2.0, pulseSpeed: 3.0 },
  };

  function drawBg(t) {
    const w = state.width, h = state.height;
    bgCtx.clearRect(0, 0, w, h);
    bgCtx.fillStyle = '#0a0a0f';
    bgCtx.fillRect(0, 0, w, h);

    const phase = state.agentPhase || 'read';
    const nebula = PHASE_NEBULA[phase] || PHASE_NEBULA.read;
    const mood = HEALTH_MOOD[state.health] || HEALTH_MOOD.green;

    // Growth vitality boosts nebula energy — growing system = vibrant, stalled = dim
    const growth = computeGrowthVitality();
    const vitalityBoost = 0.5 + growth.vitality * 1.5; // 0.5 (dormant) to 2.0 (surging)

    // Stagnation desaturation: when growth stalls, nebula shifts toward grey
    const saturation = 0.3 + growth.vitality * 0.7; // 0.3 (dormant) to 1.0 (surging)
    const nr = Math.round(nebula.r * saturation + 140 * (1 - saturation));
    const ng = Math.round(nebula.g * saturation + 140 * (1 - saturation));
    const nb = Math.round(nebula.b * saturation + 150 * (1 - saturation));

    // Phase-aware nebula glow at center (where agents live)
    const cx = w / 2, cy = h / 2;
    const nebulaRadius = Math.min(w, h) * 0.5;
    const nebulaPulse = 0.015 + Math.sin(t * 0.3 * mood.pulseSpeed) * 0.008;
    const nebulaAlpha = nebulaPulse * mood.nebulaIntensity * vitalityBoost;

    const grad = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, nebulaRadius);
    grad.addColorStop(0, `rgba(${nr},${ng},${nb},${nebulaAlpha * 1.5})`);
    grad.addColorStop(0.4, `rgba(${nr},${ng},${nb},${nebulaAlpha * 0.5})`);
    grad.addColorStop(1, 'transparent');
    bgCtx.fillStyle = grad;
    bgCtx.fillRect(0, 0, w, h);

    // Subtle secondary nebula drift (offset, slower)
    const drift = t * 0.05;
    const nx2 = cx + Math.sin(drift) * nebulaRadius * 0.3;
    const ny2 = cy + Math.cos(drift * 0.7) * nebulaRadius * 0.2;
    const grad2 = bgCtx.createRadialGradient(nx2, ny2, 0, nx2, ny2, nebulaRadius * 0.6);
    grad2.addColorStop(0, `rgba(${nr},${ng},${nb},${nebulaAlpha * 0.4})`);
    grad2.addColorStop(1, 'transparent');
    bgCtx.fillStyle = grad2;
    bgCtx.fillRect(0, 0, w, h);

    // Stars — brightness modulated by health mood and growth vitality
    const starVitality = 0.6 + growth.vitality * 0.4; // dimmer stars when stagnant
    for (const star of bgStars) {
      const flicker = Math.sin(t * star.speed * mood.pulseSpeed + star.phase) * 0.15 + star.alpha;
      const brightness = Math.max(0.02, flicker * mood.starBright * starVitality);
      bgCtx.beginPath();
      bgCtx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      bgCtx.fillStyle = `rgba(200,200,240,${brightness})`;
      bgCtx.fill();
    }

    // Context vignette — edges darken as context fills up
    const total = (state.context.system || 0) + (state.context.conversation || 0) +
                  (state.context.tools || 0) + (state.context.thinking || 0);
    const ctxPct = Math.min(1, total / (state.context.max || 200000));
    if (ctxPct > 0.3) {
      const vignetteStrength = (ctxPct - 0.3) * 0.6; // 0 to ~0.42
      const vGrad = bgCtx.createRadialGradient(cx, cy, nebulaRadius * 0.5, cx, cy, Math.max(w, h) * 0.7);
      vGrad.addColorStop(0, 'transparent');
      vGrad.addColorStop(1, `rgba(5,5,10,${vignetteStrength})`);
      bgCtx.fillStyle = vGrad;
      bgCtx.fillRect(0, 0, w, h);
    }
  }

  // ----------------------------------------------------------
  // SVG Setup (D3)
  // ----------------------------------------------------------
  const svg = d3.select('#main-viz');
  const defs = svg.append('defs');

  // Glow filters
  PALETTE_KEYS.forEach(key => {
    const filter = defs.append('filter').attr('id', `glow-${key}`).attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
    filter.append('feGaussianBlur').attr('stdDeviation', '4').attr('result', 'blur');
    filter.append('feFlood').attr('flood-color', PALETTE[key].base).attr('flood-opacity', '0.4').attr('result', 'color');
    filter.append('feComposite').attr('in', 'color').attr('in2', 'blur').attr('operator', 'in').attr('result', 'glow');
    const merge = filter.append('feMerge');
    merge.append('feMergeNode').attr('in', 'glow');
    merge.append('feMergeNode').attr('in', 'SourceGraphic');
  });

  // Purple glow for daydream
  const purpleFilter = defs.append('filter').attr('id', 'glow-purple').attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
  purpleFilter.append('feGaussianBlur').attr('stdDeviation', '3').attr('result', 'blur');
  purpleFilter.append('feFlood').attr('flood-color', '#8b5cf6').attr('flood-opacity', '0.5').attr('result', 'color');
  purpleFilter.append('feComposite').attr('in', 'color').attr('in2', 'blur').attr('operator', 'in').attr('result', 'glow');
  const pMerge = purpleFilter.append('feMerge');
  pMerge.append('feMergeNode').attr('in', 'glow');
  pMerge.append('feMergeNode').attr('in', 'SourceGraphic');

  const zoomGroup = svg.append('g').attr('id', 'zoom-group');
  const linksLayer = zoomGroup.append('g').attr('class', 'links-layer');
  const coloniesLayer = zoomGroup.append('g').attr('class', 'colonies-layer');
  const particlesLayer = zoomGroup.append('g').attr('class', 'particles-layer');
  const daydreamLayer = zoomGroup.append('g').attr('class', 'daydream-layer');
  const synapseTreeLayer = zoomGroup.append('g').attr('class', 'synapse-tree-layer');
  const agentTreeLayer = zoomGroup.append('g').attr('class', 'agent-tree-layer');

  // ----------------------------------------------------------
  // Zoom Behavior
  // ----------------------------------------------------------
  const zoomBehavior = d3.zoom()
    .scaleExtent([0.2, 5])
    .on('zoom', (event) => {
      state.zoom = event.transform.k;
      state.pan.x = event.transform.x;
      state.pan.y = event.transform.y;
      zoomGroup.attr('transform', event.transform);
      updateZoomIndicator();
    });

  svg.call(zoomBehavior);

  function updateZoomIndicator() {
    const el = document.getElementById('zoom-indicator');
    el.textContent = state.zoom.toFixed(1) + 'x';
    el.classList.add('visible');
    clearTimeout(el._timeout);
    el._timeout = setTimeout(() => el.classList.remove('visible'), 2000);
  }

  // ----------------------------------------------------------
  // Colony & Particle Data Structures
  // ----------------------------------------------------------
  class Colony {
    constructor(goal, colorKey, cx, cy) {
      this.id = goal.id || goal.name;
      this.goal = goal;
      this.colorKey = colorKey;
      this.color = PALETTE[colorKey];
      this.cx = cx;
      this.cy = cy;
      this.radius = 80;
      this.particles = [];
      this.active = false;
      this.breathPhase = Math.random() * Math.PI * 2;
      this.breathSpeed = 0.008 + Math.random() * 0.004;
    }
  }

  class Particle {
    constructor(commit, colony) {
      this.id = commit.hash || commit.id || Math.random().toString(36).slice(2);
      this.commit = commit;
      this.colony = colony;
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * colony.radius * 0.7;
      this.x = colony.cx + Math.cos(angle) * dist;
      this.y = colony.cy + Math.sin(angle) * dist;
      this.vx = (Math.random() - 0.5) * 0.3;
      this.vy = (Math.random() - 0.5) * 0.3;
      this.baseRadius = Math.min(8, 2.5 + (commit.filesChanged || 1) * 0.8);
      this.radius = this.baseRadius;
      this.age = commit.age || 0;
      this.brightness = Math.max(0.3, 1 - this.age * 0.01);
      this.type = commit.type || 'chore';
      this.isActive = commit.isActive || false;
      this.phase = Math.random() * Math.PI * 2;
      this.spawnTime = state.time;
    }
  }

  // ----------------------------------------------------------
  // Colony Layout
  // ----------------------------------------------------------
  function layoutColonies() {
    const goals = state.goals;
    if (goals.length === 0) return;

    const cx = state.width / 2;
    const cy = state.height / 2;
    const ringRadius = Math.min(state.width, state.height) * 0.38;

    goals.forEach((goal, i) => {
      const angle = (i / goals.length) * Math.PI * 2 - Math.PI / 2;
      const x = cx + Math.cos(angle) * ringRadius;
      const y = cy + Math.sin(angle) * ringRadius;
      const colorKey = PALETTE_KEYS[i % PALETTE_KEYS.length];

      if (!state.colonies.has(goal.id)) {
        state.colonies.set(goal.id, new Colony(goal, colorKey, x, y));
      } else {
        const c = state.colonies.get(goal.id);
        c.cx = x;
        c.cy = y;
      }
    });

    // Populate legend with goal colors
    const legendGoals = document.getElementById('legend-goals');
    if (legendGoals) {
      const items = legendGoals.querySelectorAll('.legend-item');
      const currentNames = new Set();
      state.colonies.forEach(colony => currentNames.add(colony.goal.name || colony.goal.id));
      const existingNames = new Set(Array.from(items).map(el => el.textContent.trim()));
      if (currentNames.size !== existingNames.size || ![...currentNames].every(n => existingNames.has(n))) {
        // Remove old items, keep title
        items.forEach(el => el.remove());
        state.colonies.forEach(colony => {
          const span = document.createElement('span');
          span.className = 'legend-item';
          const dot = document.createElement('span');
          dot.className = 'legend-dot';
          dot.style.background = colony.color.base;
          span.appendChild(dot);
          span.appendChild(document.createTextNode(colony.goal.name || colony.goal.id));
          legendGoals.appendChild(span);
        });
      }
    }
  }

  // ----------------------------------------------------------
  // Particle Physics
  // ----------------------------------------------------------
  function updatePhysics() {
    state.time++;
    const modeMultiplier = state.agentMode === 'rate_limited' ? 0.15
                         : state.agentMode === 'stagnating' ? 0.02
                         : state.agentMode === 'rest' ? 0.3
                         : 1;

    state.colonies.forEach(colony => {
      colony.breathPhase += colony.breathSpeed * modeMultiplier;
      const breath = Math.sin(colony.breathPhase) * 0.04;
      const effectiveRadius = colony.radius * (1 + breath);

      colony.particles.forEach(p => {
        // Attract toward colony center
        const dx = colony.cx - p.x;
        const dy = colony.cy - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > effectiveRadius) {
          p.vx += (dx / dist) * 0.05;
          p.vy += (dy / dist) * 0.05;
        }

        // Gentle orbital drift
        p.vx += (-dy / (dist + 10)) * 0.002 * modeMultiplier;
        p.vy += (dx / (dist + 10)) * 0.002 * modeMultiplier;

        // Repulsion from other particles
        colony.particles.forEach(other => {
          if (other === p) return;
          const pdx = p.x - other.x;
          const pdy = p.y - other.y;
          const pd = Math.sqrt(pdx * pdx + pdy * pdy);
          if (pd < 20 && pd > 0) {
            const force = (20 - pd) / 20 * 0.1;
            p.vx += (pdx / pd) * force;
            p.vy += (pdy / pd) * force;
          }
        });

        // Damping
        p.vx *= 0.95;
        p.vy *= 0.95;

        // Apply
        p.x += p.vx * modeMultiplier;
        p.y += p.vy * modeMultiplier;

        // Pulse active particles
        if (p.isActive && colony.active) {
          p.radius = p.baseRadius * (1.4 + Math.sin(state.time * 0.05) * 0.2);
        } else {
          p.radius = p.baseRadius;
        }

        // Brightness fade for stagnation
        if (state.agentMode === 'stagnating') {
          p.brightness = Math.max(0.15, p.brightness * 0.999);
        }
      });
    });
  }

  // ----------------------------------------------------------
  // Synapse Tree — Growing Neural Network
  // ----------------------------------------------------------
  // Self-modification types — only these become synapse nodes
  const SELF_MOD_TYPES = new Set(['rules', 'review', 'identity', 'skill', 'strategy', 'research', 'metrics']);

  // Find the best host agent for a synapse type
  function getSynapseHost(type) {
    const agents = Array.from(state.agents.values());
    if (agents.length === 0) return null;
    const root = agents.find(a => !a.parent);

    // Keywords to match synapse types to agent roles
    const typeKeywords = {
      research: ['research', 'scout', 'explore'],
      skill:    ['code', 'engineer', 'build', 'tool'],
      metrics:  ['data', 'analyst', 'metric', 'monitor'],
    };

    const keywords = typeKeywords[type];
    if (keywords) {
      const match = agents.find(a =>
        keywords.some(k => a.id.toLowerCase().includes(k) || (a.label || '').toLowerCase().includes(k))
      );
      if (match) return match;
    }

    // rules, strategy, review, identity → root agent
    return root || agents[0];
  }

  function initSynapseTree(synapseData) {
    if (!synapseData || synapseData.length === 0) return;

    const events = synapseData
      .filter(s => SELF_MOD_TYPES.has(s.type))
      .slice(0, 100).reverse();

    if (events.length === 0) return;

    // Group by type to compute branch chain positions
    const typeGroups = {};
    events.forEach(s => {
      if (!typeGroups[s.type]) typeGroups[s.type] = [];
      typeGroups[s.type].push(s);
    });

    const nodes = [];
    Object.entries(typeGroups).forEach(([type, group]) => {
      const typeAngle = SYNAPSE_TYPE_ANGLES[type] || 0;
      group.forEach((s, j) => {
        // Branch offset from host: grows outward with organic jitter
        const baseDist = 22 + j * 14;
        const hashSeed = (s.hash || 'x').charCodeAt(0) + ((s.hash || 'xx').charCodeAt(1) || 0) * 0.3;
        const jitter = Math.sin(j * 1.7 + hashSeed * 0.05) * 0.3;
        const curve = Math.sin(j * 0.4 + hashSeed * 0.02) * 0.2;

        nodes.push({
          hash: s.hash,
          date: s.date,
          message: s.message,
          type: s.type || 'other',
          index: nodes.length,
          _branchAngle: typeAngle,
          _branchJitter: jitter + curve,
          _branchDist: baseDist,
          _branchOrder: j,
          x: 0, y: 0,
          age: s.date ? (Date.now() - new Date(s.date).getTime()) / 86400000 : 30,
          isNew: false,
        });
      });
    });

    state.synapses = nodes;
    if (state.synapseSim) { state.synapseSim.stop(); state.synapseSim = null; }
  }

  function addSynapse(synapse) {
    if (!SELF_MOD_TYPES.has(synapse.type)) return;

    const typeAngle = SYNAPSE_TYPE_ANGLES[synapse.type] || 0;
    const sameType = state.synapses.filter(n => n.type === synapse.type);
    const j = sameType.length;
    const baseDist = 22 + j * 14;
    const hashSeed = (synapse.hash || 'x').charCodeAt(0);
    const jitter = Math.sin(j * 1.7 + hashSeed * 0.05) * 0.3;
    const curve = Math.sin(j * 0.4 + hashSeed * 0.02) * 0.2;

    const node = {
      hash: synapse.hash,
      date: synapse.date,
      message: synapse.message,
      type: synapse.type || 'other',
      index: state.synapses.length,
      _branchAngle: typeAngle,
      _branchJitter: jitter + curve,
      _branchDist: baseDist,
      _branchOrder: j,
      x: 0, y: 0,
      age: 0,
      isNew: true,
    };
    state.synapses.push(node);
    setTimeout(() => { node.isNew = false; }, 2000);
  }

  function renderSynapseTree() {
    const nodes = state.synapses;
    if (nodes.length === 0) {
      synapseTreeLayer.selectAll('*').remove();
      return;
    }

    const cx = state._treeCx || state.width / 2;
    const cy = state._treeCy || state.height / 2;

    // Compute absolute positions from host agent positions each frame
    const typeChains = {};
    const dendrites = [];

    nodes.forEach(n => {
      const host = getSynapseHost(n.type);
      const hx = host ? host.x : cx;
      const hy = host ? host.y : cy;
      const hr = host ? (host.nodeRadius || 20) : 20;

      // Direction: outward from canvas center through host agent
      const isCenter = !host || (Math.abs(hx - cx) < 5 && Math.abs(hy - cy) < 5);
      let angle;
      if (isCenter) {
        // Root agent at center — fan branches by type angle
        angle = n._branchAngle + n._branchJitter;
      } else {
        // Off-center agent — grow outward, slight type spread
        const outAngle = Math.atan2(hy - cy, hx - cx);
        const typeSpread = ((n._branchAngle / (2 * Math.PI)) - 0.5) * Math.PI * 0.5;
        angle = outAngle + typeSpread + n._branchJitter;
      }

      const dist = hr + n._branchDist;

      // Subtle organic breathing
      const bx = Math.sin(state.time * 0.008 + n.index * 0.5) * 1.2;
      const by = Math.cos(state.time * 0.006 + n.index * 0.7) * 1.2;

      n.x = hx + Math.cos(angle) * dist + bx;
      n.y = hy + Math.sin(angle) * dist + by;
      n._hostX = hx;
      n._hostY = hy;
      n._hostRadius = hr;

      // Build type chains for dendrites
      if (!typeChains[n.type]) typeChains[n.type] = [];
      typeChains[n.type].push(n);
    });

    // Build dendrites: host edge → first node, then chain connections
    Object.values(typeChains).forEach(chain => {
      chain.forEach((n, j) => {
        if (j === 0) {
          // Root dendrite from host agent edge
          const dx = n.x - n._hostX, dy = n.y - n._hostY;
          const d = Math.sqrt(dx * dx + dy * dy) || 1;
          dendrites.push({
            source: {
              x: n._hostX + (dx / d) * n._hostRadius,
              y: n._hostY + (dy / d) * n._hostRadius,
            },
            target: n,
            id: `syn-host-${n.index}`,
            isRoot: true,
          });
        } else {
          dendrites.push({
            source: chain[j - 1],
            target: n,
            id: `syn-${chain[j - 1].index}-${n.index}`,
            isRoot: false,
          });
        }
      });
    });

    // Growth vitality modulates entire synapse tree visibility
    const growth = computeGrowthVitality();
    const treeBrightness = 0.3 + growth.vitality * 0.7; // 0.3 when dormant, 1.0 when surging
    const breathe = (0.25 + Math.sin(state.time * 0.015) * 0.1) * treeBrightness;

    // Render dendrites (curved paths for organic coral feel)
    const dLinks = synapseTreeLayer.selectAll('.synapse-dendrite').data(dendrites, d => d.id);
    dLinks.enter().append('path').attr('class', 'synapse-dendrite')
      .attr('fill', 'none')
      .merge(dLinks)
      .attr('d', d => {
        // Slight curve for organic branch look
        const mx = (d.source.x + d.target.x) / 2;
        const my = (d.source.y + d.target.y) / 2;
        const perpX = -(d.target.y - d.source.y) * 0.15;
        const perpY = (d.target.x - d.source.x) * 0.15;
        return `M${d.source.x},${d.source.y} Q${mx + perpX},${my + perpY} ${d.target.x},${d.target.y}`;
      })
      .attr('stroke', d => {
        const c = SYNAPSE_COLORS[d.target.type] || SYNAPSE_COLORS.other;
        return c.glow + (d.isRoot ? breathe * 0.4 : breathe * 0.6) + ')';
      })
      .attr('stroke-width', d => {
        if (d.target.isNew) return 2.2;
        return d.isRoot ? 1.2 : 0.7;
      })
      .attr('opacity', d => d.target.isNew ? 0.9 : breathe);
    dLinks.exit().remove();

    // Render synapse nodes
    const sNodes = synapseTreeLayer.selectAll('.synapse-node').data(nodes, d => d.hash);
    const sEnter = sNodes.enter().append('circle').attr('class', 'synapse-node')
      .attr('r', 0)
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        const tooltip = document.getElementById('tooltip');
        const typeLabel = d.type.charAt(0).toUpperCase() + d.type.slice(1);
        const isRecursive = ['rules', 'identity', 'review', 'strategy'].includes(d.type);
        const prefix = isRecursive ? '\u21BA ' : ''; // ↺ for recursive
        tooltip.querySelector('.tt-message').textContent = prefix + (d.message || typeLabel + ' modification');
        const ageLabel = d.age < 1 ? 'today' : d.age < 7 ? Math.floor(d.age) + ' days ago' : Math.floor(d.age / 7) + ' weeks ago';
        const recursiveLabel = isRecursive ? 'Self-modification' : 'Knowledge gained';
        tooltip.querySelector('.tt-meta').textContent = recursiveLabel + ' \u2022 ' + typeLabel + ' \u2022 ' + ageLabel;
        tooltip.style.left = event.clientX + 12 + 'px';
        tooltip.style.top = event.clientY - 10 + 'px';
        tooltip.classList.add('visible');
      })
      .on('mouseleave', function() {
        document.getElementById('tooltip').classList.remove('visible');
      });
    sEnter.transition().duration(800).attr('r', 4);

    sEnter.merge(sNodes)
      .attr('cx', d => d.x).attr('cy', d => d.y)
      .attr('r', d => {
        if (d.age < 1) return 6 + Math.sin(state.time * 0.1) * 2; // today: large, pulsing
        if (d.age < 3) return 4.5 + Math.sin(state.time * 0.06) * 1; // recent: medium pulse
        const ageFade = Math.max(0.5, 1 - d.age * 0.012);
        return 2.5 + ageFade * 2;
      })
      .attr('fill', d => {
        const c = SYNAPSE_COLORS[d.type] || SYNAPSE_COLORS.other;
        // Fresh learning glows bright, old knowledge dims
        const freshGlow = d.age < 1 ? 0.95 : d.age < 3 ? 0.7 : d.age < 7 ? 0.5 : Math.max(0.1, 0.4 - d.age * 0.004);
        return c.glow + (freshGlow * treeBrightness) + ')';
      })
      .attr('stroke', d => {
        if (d.age < 1) return (SYNAPSE_COLORS[d.type] || SYNAPSE_COLORS.other).base;
        if (d.age < 3) return (SYNAPSE_COLORS[d.type] || SYNAPSE_COLORS.other).glow + '0.4)';
        return 'none';
      })
      .attr('stroke-width', d => d.age < 1 ? 2 : d.age < 3 ? 1 : 0)
      .attr('filter', d => {
        // Glow halo for very fresh learning (< 1 day)
        if (d.age < 1) {
          const typeKey = Object.keys(PALETTE).find(k => PALETTE[k].base === (SYNAPSE_COLORS[d.type] || {}).base);
          return typeKey ? `url(#glow-${typeKey})` : 'none';
        }
        return 'none';
      });
    sNodes.exit().remove();

    // Recursive learning indicators — pulsing echo rings on self-modification synapses
    // These represent the system learning about itself (rules, identity, review, strategy)
    const RECURSIVE_TYPES = new Set(['rules', 'identity', 'review', 'strategy']);
    const recursiveNodes = nodes.filter(n => RECURSIVE_TYPES.has(n.type) && n.age < 14);
    const echoRings = synapseTreeLayer.selectAll('.synapse-echo').data(recursiveNodes, d => d.hash);

    echoRings.enter()
      .append('circle')
      .attr('class', 'synapse-echo')
      .attr('fill', 'none')
      .merge(echoRings)
      .attr('cx', d => d.x).attr('cy', d => d.y)
      .attr('r', d => {
        // Pulsing outward ring — creates "echo" effect of self-modification
        const pulse = (state.time * 0.02 + d.index * 0.5) % 1;
        return 8 + pulse * 18;
      })
      .attr('stroke', d => {
        const c = SYNAPSE_COLORS[d.type] || SYNAPSE_COLORS.other;
        const pulse = (state.time * 0.02 + d.index * 0.5) % 1;
        return c.glow + (0.3 * (1 - pulse) * treeBrightness) + ')';
      })
      .attr('stroke-width', d => {
        const pulse = (state.time * 0.02 + d.index * 0.5) % 1;
        return 1.5 * (1 - pulse);
      });
    echoRings.exit().remove();

    // Synapse labels at high zoom — show commit message
    if (state.zoom > 2.5) {
      const sLabels = synapseTreeLayer.selectAll('.synapse-label').data(nodes, d => d.hash);
      sLabels.enter().append('text').attr('class', 'synapse-label')
        .attr('font-family', 'var(--font-mono)')
        .attr('font-size', 8)
        .attr('pointer-events', 'none')
        .merge(sLabels)
        .attr('x', d => d.x + 8).attr('y', d => d.y + 3)
        .attr('fill', d => {
          const c = SYNAPSE_COLORS[d.type] || SYNAPSE_COLORS.other;
          return c.glow + '0.6)';
        })
        .text(d => {
          const msg = d.message || '';
          return msg.length > 30 ? msg.slice(0, 28) + '..' : msg;
        });
      sLabels.exit().remove();
    } else {
      synapseTreeLayer.selectAll('.synapse-label').remove();
    }

    // Remove old center label
    synapseTreeLayer.selectAll('.synapse-count-label').remove();
  }

  // ----------------------------------------------------------
  // Document Constellation — planning docs as orbital nodes
  // ----------------------------------------------------------
  const docsLayer = zoomGroup.append('g').attr('class', 'docs-layer');

  // Doc type icons (single-char shorthand)
  const DOC_ICONS = {
    'GOALS.md': 'G', 'ASSETS.md': 'A', 'STATE.md': 'S',
    'STRATEGY.md': 'T', 'OPPORTUNITIES.md': 'O', 'METRICS.md': 'M',
    'LOG.md': 'L', 'RULES.md': 'R',
  };

  function renderDocuments() {
    const docs = state.documents;
    if (!docs || Object.keys(docs).length === 0) {
      docsLayer.selectAll('*').remove();
      return;
    }

    const cx = state._treeCx || state.width / 2;
    const cy = state._treeCy || state.height / 2;
    const now = Date.now();

    // Build doc data array with positions in a loose orbit around agents
    const docKeys = Object.keys(docs).filter(k => docs[k].exists);
    const orbitRadius = Math.min(state.width, state.height) * 0.14;
    const docData = docKeys.map((name, i) => {
      const d = docs[name];
      // Freshness: 0 (stale) to 1 (just modified)
      const mtime = d.mtime ? new Date(d.mtime).getTime() : now - 86400000 * 7;
      const hoursAgo = (now - mtime) / 3600000;
      const freshness = Math.max(0, Math.min(1, 1 - hoursAgo / 168));

      // Orbit speed: fresh docs orbit faster (recently touched = active)
      const baseAngle = (2 * Math.PI * i) / docKeys.length - Math.PI / 2;
      const orbitSpeed = 0.0002 + freshness * 0.001; // fresh = faster orbit
      const angle = baseAngle + state.time * orbitSpeed;

      return {
        name,
        icon: DOC_ICONS[name] || name.charAt(0),
        x: cx + Math.cos(angle) * orbitRadius,
        y: cy + Math.sin(angle) * orbitRadius,
        freshness,
        hoursAgo,
        size: d.size || 0,
      };
    });

    // Doc nodes — small circles with letter inside
    const docNodes = docsLayer.selectAll('.doc-node-g').data(docData, d => d.name);

    const entering = docNodes.enter().append('g').attr('class', 'doc-node-g')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        const tooltip = document.getElementById('tooltip');
        const DOC_DESCRIPTIONS = {
          'STATE.md': 'Current operational state — position, decisions, blockers',
          'GOALS.md': 'Master goals — what the system is trying to achieve',
          'STRATEGY.md': 'Strategic plan — how goals will be accomplished',
          'METRICS.md': 'Quantitative progress — KPIs and week-over-week trends',
          'OPPORTUNITIES.md': 'Ranked idea board — proposed, approved, in-progress items',
          'LOG.md': 'Daily narrative — focus areas, accomplishments, blockers',
          'ASSETS.md': 'Available resources — financial, technical, skills, network',
          'CLAUDE.md': 'System identity and core instructions',
          'napkin.md': 'Working memory — mistakes, patterns, corrections',
        };
        const baseName = d.name.split('/').pop();
        tooltip.querySelector('.tt-message').textContent = baseName;
        const freshLabel = d.hoursAgo < 1 ? 'just now' : d.hoursAgo < 24 ? Math.floor(d.hoursAgo) + 'h ago' : Math.floor(d.hoursAgo / 24) + 'd ago';
        const desc = DOC_DESCRIPTIONS[baseName] || '';
        tooltip.querySelector('.tt-meta').textContent = (desc ? desc + ' \u2022 ' : '') + freshLabel;
        tooltip.querySelector('.tt-stat.add').textContent = '';
        tooltip.querySelector('.tt-stat.del').textContent = '';
        tooltip.querySelector('.tt-stat.files').textContent = d.size ? Math.round(d.size / 1024) + ' KB' : '';
        tooltip.style.left = event.clientX + 12 + 'px';
        tooltip.style.top = event.clientY - 10 + 'px';
        tooltip.classList.add('visible');
      })
      .on('mouseleave', function() {
        document.getElementById('tooltip').classList.remove('visible');
      })
      .on('click', function(event, d) { openSidebarPanel('raw'); });

    entering.append('circle').attr('class', 'doc-ring');
    entering.append('text').attr('class', 'doc-icon');

    const merged = entering.merge(docNodes);

    // Subtle breathing offset
    merged.attr('transform', (d, i) => {
      const bx = Math.sin(state.time * 0.006 + i * 1.2) * 2;
      const by = Math.cos(state.time * 0.005 + i * 0.9) * 2;
      return `translate(${d.x + bx},${d.y + by})`;
    });

    merged.select('.doc-ring')
      .attr('r', d => 12 + d.freshness * 4)
      .attr('fill', d => {
        const phaseNeb = PHASE_NEBULA[state.agentPhase || 'read'] || PHASE_NEBULA.read;
        return `rgba(${phaseNeb.r},${phaseNeb.g},${phaseNeb.b},${0.04 + d.freshness * 0.08})`;
      })
      .attr('stroke', d => {
        const phaseNeb = PHASE_NEBULA[state.agentPhase || 'read'] || PHASE_NEBULA.read;
        return `rgba(${phaseNeb.r},${phaseNeb.g},${phaseNeb.b},${0.1 + d.freshness * 0.3})`;
      })
      .attr('stroke-width', d => 0.5 + d.freshness * 1);

    merged.select('.doc-icon')
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'central')
      .attr('font-family', 'var(--font-mono)')
      .attr('font-size', 10)
      .attr('font-weight', 600)
      .attr('fill', d => {
        const phaseNeb = PHASE_NEBULA[state.agentPhase || 'read'] || PHASE_NEBULA.read;
        return `rgba(${phaseNeb.r},${phaseNeb.g},${phaseNeb.b},${0.25 + d.freshness * 0.5})`;
      })
      .text(d => d.icon);

    docNodes.exit().remove();

    // Connection lines from recent tool calls to docs
    const recentDocCalls = (state.toolCalls || []).filter(tc =>
      (tc.tool === 'Read' || tc.tool === 'Write' || tc.tool === 'Edit') &&
      tc.target && docKeys.some(dk => tc.target.includes(dk.replace('.md', '')))
    ).slice(0, 5);

    const docCallData = recentDocCalls.map(tc => {
      const agent = state.agents.get(tc.agent);
      const matchDoc = docData.find(d => tc.target.includes(d.name.replace('.md', '')));
      if (!agent || !matchDoc) return null;
      return { id: tc.id + '-doc', agent, doc: matchDoc, tool: tc.tool };
    }).filter(Boolean);

    const docLinks = docsLayer.selectAll('.doc-interaction').data(docCallData, d => d.id);
    docLinks.enter().append('line').attr('class', 'doc-interaction')
      .merge(docLinks)
      .attr('x1', d => d.agent.x).attr('y1', d => d.agent.y)
      .attr('x2', d => d.doc.x).attr('y2', d => d.doc.y)
      .attr('stroke', d => {
        const phaseNeb = PHASE_NEBULA[state.agentPhase || 'read'] || PHASE_NEBULA.read;
        return `rgba(${phaseNeb.r},${phaseNeb.g},${phaseNeb.b},0.12)`;
      })
      .attr('stroke-width', 0.8)
      .attr('stroke-dasharray', '3,6');
    docLinks.exit().remove();
  }

  // ----------------------------------------------------------
  // Growth Vitality — synapse rate drives canvas energy
  // ----------------------------------------------------------
  function computeGrowthVitality() {
    const synapses = state.synapses;
    if (synapses.length === 0) return { rate: 0, vitality: 0, label: 'dormant' };

    const now = Date.now();
    // Count synapses from last 7 days, 24 hours, and total
    const week = synapses.filter(s => s.age < 7).length;
    const day = synapses.filter(s => s.age < 1).length;
    const total = synapses.length;

    // Vitality: 0-1 based on recent learning rate
    // High vitality = many recent synapses relative to total
    const ratePerDay = week / 7;
    const vitality = Math.min(1, ratePerDay / 3); // 3+ per day = max vitality

    let label;
    if (day >= 3) label = 'surging';
    else if (day >= 1) label = 'active';
    else if (week >= 3) label = 'steady';
    else if (total > 0) label = 'slowing';
    else label = 'dormant';

    return { rate: ratePerDay, vitality, label, total, week, day };
  }

  // ----------------------------------------------------------
  // Daydream Spark Effects
  // ----------------------------------------------------------
  function triggerDaydreamSpark(sourceColony, targetColony) {
    const spark = {
      id: 'spark-' + Date.now() + Math.random(),
      sx: sourceColony.cx, sy: sourceColony.cy,
      tx: targetColony.cx, ty: targetColony.cy,
      birth: state.time,
      lifetime: 120, // frames
      particles: [],
    };
    // Generate 6-10 spark particles
    const mx = (spark.sx + spark.tx) / 2;
    const my = (spark.sy + spark.ty) / 2;
    for (let i = 0; i < 8; i++) {
      spark.particles.push({
        x: mx, y: my,
        vx: (Math.random() - 0.5) * 3,
        vy: (Math.random() - 0.5) * 3,
        life: 60 + Math.random() * 40,
        age: 0,
      });
    }
    state.daydreamSparks.push(spark);
    // Also create a daydream link between colonies
    if (sourceColony.particles.length > 0 && targetColony.particles.length > 0) {
      const sp = sourceColony.particles[Math.floor(Math.random() * sourceColony.particles.length)];
      const tp = targetColony.particles[Math.floor(Math.random() * targetColony.particles.length)];
      state.daydreamLinks.push({
        id: 'dd-spark-' + Date.now() + Math.random(),
        source: sp, target: tp,
        hit: Math.random() > 0.6,
        opportunity: Math.random() > 0.7,
        birth: state.time,
      });
    }
  }

  function renderDaydreamSparks() {
    // Update spark particle physics
    state.daydreamSparks.forEach(spark => {
      spark.particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.96;
        p.vy *= 0.96;
        p.age++;
      });
    });
    // Remove expired sparks
    state.daydreamSparks = state.daydreamSparks.filter(s => (state.time - s.birth) < s.lifetime);

    // Render spark particles
    const allSparkParticles = [];
    state.daydreamSparks.forEach(spark => {
      spark.particles.forEach((p, i) => {
        if (p.age < p.life) {
          allSparkParticles.push({ ...p, id: spark.id + '-' + i, opacity: 1 - (p.age / p.life) });
        }
      });
    });

    const sparkDots = daydreamLayer.selectAll('.spark-particle').data(allSparkParticles, d => d.id);
    sparkDots.enter().append('circle').attr('class', 'spark-particle')
      .merge(sparkDots)
      .attr('cx', d => d.x).attr('cy', d => d.y)
      .attr('r', d => 2 * d.opacity)
      .attr('fill', '#a78bfa')
      .attr('opacity', d => d.opacity * 0.8);
    sparkDots.exit().remove();
  }

  // ----------------------------------------------------------
  // Rendering
  // ----------------------------------------------------------
  function render() {
    // Colony backgrounds (halos)
    const colonyData = Array.from(state.colonies.values());
    const colonyHalos = coloniesLayer.selectAll('.colony-halo').data(colonyData, d => d.id);

    colonyHalos.enter()
      .append('circle')
      .attr('class', 'colony-halo')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        const tooltip = document.getElementById('tooltip');
        tooltip.querySelector('.tt-message').textContent = d.goal.name || d.id;
        const recent = d.particles.filter(p => p.age < 7).length;
        const momentum = recent > 5 ? 'high momentum' : recent > 0 ? recent + ' commits this week' : 'no recent activity';
        const total = d.particles.length + ' total commits';
        const status = d.active ? 'ACTIVE' : 'idle';
        tooltip.querySelector('.tt-meta').textContent = [status, momentum, total].filter(Boolean).join(' \u2022 ');
        tooltip.querySelector('.tt-stat.add').textContent = '';
        tooltip.querySelector('.tt-stat.del').textContent = '';
        tooltip.querySelector('.tt-stat.files').textContent = '';
        tooltip.style.left = event.clientX + 12 + 'px';
        tooltip.style.top = event.clientY - 10 + 'px';
        tooltip.classList.add('visible');
      })
      .on('mouseleave', function() {
        document.getElementById('tooltip').classList.remove('visible');
      })
      .on('click', function(event, d) {
        openSidebarPanel('goals');
      })
      .merge(colonyHalos)
      .attr('cx', d => d.cx)
      .attr('cy', d => d.cy)
      .attr('r', d => d.radius + 20 + Math.sin(d.breathPhase) * 5)
      .attr('fill', 'none')
      .attr('stroke', d => d.color.glow + (d.active ? '0.18)' : '0.08)'))
      .attr('stroke-width', d => d.active ? 1.5 : 0.5)
      .attr('filter', 'none');

    colonyHalos.exit().remove();

    coloniesLayer.selectAll('.colony-momentum-arc').remove();
    coloniesLayer.selectAll('.colony-stalled').remove();

    // Colony labels — goal name + commit count
    const labelData = state.zoom > 0.3 ? colonyData : [];
    const labels = coloniesLayer.selectAll('.colony-label').data(labelData, d => d.id);

    const labelEntering = labels.enter()
      .append('g')
      .attr('class', 'colony-label');

    labelEntering.append('text')
      .attr('class', 'colony-name')
      .attr('text-anchor', 'middle')
      .attr('font-family', 'var(--font-sans)')
      .attr('font-weight', '600');

    labelEntering.append('text')
      .attr('class', 'colony-count')
      .attr('text-anchor', 'middle')
      .attr('font-family', 'var(--font-mono)')
      .attr('font-size', 9);

    const labelMerged = labelEntering.merge(labels);

    labelMerged.attr('transform', d => `translate(${d.cx},${d.cy + d.radius + 30})`);

    labelMerged.select('.colony-name')
      .attr('fill', d => d.color.base)
      .attr('opacity', d => d.active ? 0.6 : 0.35)
      .attr('font-size', d => Math.max(10, 12 / state.zoom))
      .text(d => d.goal.name || d.id);

    labelMerged.select('.colony-count')
      .attr('y', 14)
      .attr('fill', d => d.color.glow + '0.4)')
      .attr('opacity', d => d.active ? 0.5 : 0.25)
      .text(d => {
        const recent = d.particles.filter(p => p.age < 7).length;
        const label = recent > 0 ? `${recent} this week` : `${d.particles.length} total`;
        return label + (d.active ? ' \u2022 active' : '');
      });

    labels.exit().remove();

    // Particles
    const allParticles = [];
    state.colonies.forEach(c => c.particles.forEach(p => allParticles.push(p)));

    // Particle groups
    const pGroups = particlesLayer.selectAll('.particle-g').data(allParticles, d => d.id);

    const entering = pGroups.enter()
      .append('g')
      .attr('class', 'particle-g')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) { showTooltip(event, d); })
      .on('mousemove', function(event, d) { moveTooltip(event); })
      .on('mouseleave', function() { hideTooltip(); });

    // Main circle
    entering.append('circle')
      .attr('class', 'p-body');

    // Type ring (visible at close zoom)
    entering.append('circle')
      .attr('class', 'p-ring');

    const merged = entering.merge(pGroups);

    merged.attr('transform', d => `translate(${d.x},${d.y})`);

    merged.select('.p-body')
      .attr('r', d => d.radius)
      .attr('fill', d => {
        const c = d.colony.color;
        const b = d.brightness * (d.colony.active ? 0.5 : 0.25);
        return c.glow + b + ')';
      })
      .attr('stroke', d => d.isActive && d.colony.active ? d.colony.color.base : 'none')
      .attr('stroke-width', d => d.isActive ? 1.5 : 0)
      .attr('stroke-opacity', 0.6)
      .attr('filter', 'none');

    // Type ring visibility based on zoom
    merged.select('.p-ring')
      .attr('r', d => d.radius + 2.5)
      .attr('fill', 'none')
      .attr('stroke', d => COMMIT_TYPES[d.type] || '#6b7280')
      .attr('stroke-width', 1.5)
      .attr('opacity', state.zoom > 1.5 ? 0.7 : 0);

    // Commit message labels at deep zoom (semantic zoom)
    if (state.zoom > 2.5) {
      let pLabels = particlesLayer.selectAll('.particle-label').data(allParticles.slice(0, 40), d => d.id);
      pLabels.enter().append('text').attr('class', 'particle-label')
        .attr('font-size', 8)
        .attr('font-family', 'var(--font-mono)')
        .attr('fill', 'rgba(255,255,255,0.4)')
        .merge(pLabels)
        .attr('x', d => d.x + d.radius + 4)
        .attr('y', d => d.y + 3)
        .text(d => {
          const msg = d.commit.message || '';
          return msg.length > 35 ? msg.slice(0, 33) + '..' : msg;
        });
      pLabels.exit().remove();
    } else {
      particlesLayer.selectAll('.particle-label').remove();
    }

    pGroups.exit()
      .transition().duration(500)
      .attr('opacity', 0)
      .remove();

    // Daydream connections — animated lightning arcs
    // Expire old daydream links (fade after ~3 seconds / 180 frames)
    const DAYDREAM_LIFETIME = 180;
    state.daydreamLinks = state.daydreamLinks.filter(d => (state.time - (d.birth || 0)) < DAYDREAM_LIFETIME);
    const linkData = state.daydreamLinks;
    const links = daydreamLayer.selectAll('.daydream-link').data(linkData, d => d.id);

    links.enter()
      .append('path')
      .attr('class', 'daydream-link')
      .attr('fill', 'none')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        const tooltip = document.getElementById('tooltip');
        const label = d.hit ? 'Daydream Hit' : d.opportunity ? 'Daydream Opportunity' : 'Daydream Link';
        tooltip.querySelector('.tt-message').textContent = label;
        tooltip.querySelector('.tt-meta').textContent = 'Cross-goal connection between colonies';
        tooltip.querySelector('.tt-stat.add').textContent = '';
        tooltip.querySelector('.tt-stat.del').textContent = '';
        tooltip.querySelector('.tt-stat.files').textContent = '';
        tooltip.style.left = event.clientX + 12 + 'px';
        tooltip.style.top = event.clientY - 10 + 'px';
        tooltip.classList.add('visible');
      })
      .on('mouseleave', function() {
        document.getElementById('tooltip').classList.remove('visible');
      })
      .merge(links)
      .attr('d', d => {
        const mx = (d.source.x + d.target.x) / 2;
        const my = (d.source.y + d.target.y) / 2;
        // Jitter control point for electrical crackle effect
        const jx = mx + (Math.sin(state.time * 0.07 + d.source.x) * 15);
        const jy = my + (Math.cos(state.time * 0.09 + d.target.y) * 15);
        return `M${d.source.x},${d.source.y} Q${jx},${jy} ${d.target.x},${d.target.y}`;
      })
      .attr('stroke', '#8b5cf6')
      .attr('stroke-width', d => d.hit ? 2 : 0.8)
      .attr('stroke-opacity', d => {
        const age = state.time - (d.birth || 0);
        const fade = Math.max(0, 1 - age / DAYDREAM_LIFETIME);
        return d.hit ? (0.5 + Math.sin(state.time * 0.03) * 0.25) * fade : 0.12 * fade;
      })
      .attr('stroke-dasharray', d => d.hit ? `${4 + Math.sin(state.time * 0.05) * 2},3` : '3,8')
      .attr('filter', d => d.hit ? 'url(#glow-purple)' : 'none');

    links.exit().remove();

    // Daydream midpoint nodes (opportunities) — with pulse
    const midpoints = linkData.filter(d => d.opportunity);
    const midDots = daydreamLayer.selectAll('.daydream-mid').data(midpoints, d => d.id);

    midDots.enter()
      .append('circle')
      .attr('class', 'daydream-mid')
      .merge(midDots)
      .attr('cx', d => {
        const mx = (d.source.x + d.target.x) / 2;
        return mx + Math.sin(state.time * 0.07 + d.source.x) * 8;
      })
      .attr('cy', d => {
        const my = (d.source.y + d.target.y) / 2;
        return my + Math.cos(state.time * 0.09 + d.target.y) * 8;
      })
      .attr('r', d => 4 + Math.sin(state.time * 0.06) * 1.5)
      .attr('fill', '#a78bfa')
      .attr('opacity', d => {
        const age = state.time - (d.birth || 0);
        const fade = Math.max(0, 1 - age / DAYDREAM_LIFETIME);
        return (0.6 + Math.sin(state.time * 0.04) * 0.3) * fade;
      })
      .attr('filter', 'url(#glow-purple)');

    midDots.exit().remove();

    // Render spark effects
    renderDaydreamSparks();
  }

  // ----------------------------------------------------------
  // Tooltip
  // ----------------------------------------------------------
  const tooltipEl = document.getElementById('tooltip');

  function showTooltip(event, d) {
    state.hoveredParticle = d;
    const tt = tooltipEl;
    tt.querySelector('.tt-message').textContent = d.commit.message || 'No message';
    tt.querySelector('.tt-meta').textContent = d.commit.timestamp || '--';
    tt.querySelector('.tt-stat.add').textContent = '+' + (d.commit.additions || 0);
    tt.querySelector('.tt-stat.del').textContent = '-' + (d.commit.deletions || 0);
    tt.querySelector('.tt-stat.files').textContent = (d.commit.filesChanged || 0) + ' files';
    tt.classList.add('visible');
    moveTooltip(event);
  }

  function moveTooltip(event) {
    const tt = tooltipEl;
    let x = event.clientX + 14;
    let y = event.clientY + 14;
    if (x + 280 > state.width) x = event.clientX - 294;
    if (y + 120 > state.height) y = event.clientY - 130;
    tt.style.left = x + 'px';
    tt.style.top = y + 'px';
  }

  function hideTooltip() {
    state.hoveredParticle = null;
    tooltipEl.classList.remove('visible');
  }

  // ----------------------------------------------------------
  // Sidebar Logic
  // ----------------------------------------------------------
  document.querySelectorAll('.sidebar-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      const panel = tab.dataset.panel;
      const wasActive = tab.classList.contains('active') && state.sidebarOpen;

      document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.remove('active'));

      if (wasActive) {
        state.sidebarOpen = false;
        document.getElementById('sidebar').classList.remove('open');
      } else {
        tab.classList.add('active');
        document.getElementById(`panel-${panel}`).classList.add('active');
        state.sidebarOpen = true;
        state.activePanel = panel;
        document.getElementById('sidebar').classList.add('open');
      }
    });
  });

  function openSidebarPanel(panelName) {
    document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.remove('active'));
    const tab = document.querySelector(`.sidebar-tab[data-panel="${panelName}"]`);
    if (tab) tab.classList.add('active');
    const panel = document.getElementById(`panel-${panelName}`);
    if (panel) panel.classList.add('active');
    state.sidebarOpen = true;
    state.activePanel = panelName;
    document.getElementById('sidebar').classList.add('open');
  }

  // ----------------------------------------------------------
  // Sidebar Rendering
  // ----------------------------------------------------------
  function updateSidebarOverview() {
    // Update HUD task section
    if (state.activeTask) {
      const t = state.activeTask;
      const colony = state.colonies.get(t.goalId);
      const badge = document.getElementById('hud-goal-badge');
      if (colony) {
        badge.style.background = colony.color.dim;
        badge.style.color = colony.color.base;
      }
      badge.textContent = t.goalName || t.goalId || 'Agent';
      document.getElementById('hud-task-name').textContent = t.name || 'Working...';
      document.getElementById('hud-task-status').textContent = t.status || '';
    }

    // Update HUD metrics
    const hudTasks = document.getElementById('hud-tasks');
    if (hudTasks) hudTasks.textContent = state.metrics.tasksPerWeek;

    // Update sidebar daydream stat
    const dd = document.getElementById('num-daydream');
    if (dd) dd.textContent = state.metrics.daydreamHitRate + '%';
  }

  function updateGoalsPanel() {
    const container = document.getElementById('goal-progress-container');
    container.innerHTML = '';

    state.goals.forEach((goal, i) => {
      const colorKey = PALETTE_KEYS[i % PALETTE_KEYS.length];
      const color = PALETTE[colorKey];
      const pct = goal.progress || 0;

      const item = document.createElement('div');
      item.className = 'goal-progress-item';
      item.innerHTML = `
        <div class="goal-label">
          <span class="goal-name">${escapeHtml(goal.name)}</span>
          <span class="goal-pct">${pct}%</span>
        </div>
        <div class="progress-track">
          <div class="progress-fill" style="width:${pct}%;background:${color.base}"></div>
        </div>
      `;
      container.appendChild(item);
    });

    // Allocation bar
    const bar = document.getElementById('allocation-bar');
    const legend = document.getElementById('alloc-legend');
    bar.innerHTML = '';
    legend.innerHTML = '';

    const total = state.goals.reduce((s, g) => s + (g.commits7d || 1), 0);
    state.goals.forEach((goal, i) => {
      const colorKey = PALETTE_KEYS[i % PALETTE_KEYS.length];
      const pct = ((goal.commits7d || 1) / total) * 100;
      const seg = document.createElement('div');
      seg.className = 'alloc-segment';
      seg.style.width = pct + '%';
      seg.style.background = PALETTE[colorKey].base;
      bar.appendChild(seg);

      const li = document.createElement('div');
      li.className = 'alloc-legend-item';
      li.innerHTML = `<span class="alloc-dot" style="background:${PALETTE[colorKey].base}"></span>${escapeHtml(goal.name)}`;
      legend.appendChild(li);
    });
  }

  // ----------------------------------------------------------
  // System Architecture Panel
  // ----------------------------------------------------------
  function updateSystemPanel() {
    // Goals section
    const goalsContainer = document.getElementById('system-goals-container');
    if (state.goalsText.length > 0) {
      goalsContainer.innerHTML = '';
      state.goalsText.forEach((goal, i) => {
        const colorKey = PALETTE_KEYS[i % PALETTE_KEYS.length];
        const color = PALETTE[colorKey];
        const card = document.createElement('div');
        card.style.cssText = `
          border-left: 3px solid ${color.base};
          padding: 8px 12px;
          margin-bottom: 10px;
          background: rgba(${color.h === 214 ? '74,158,255' : color.h === 160 ? '52,211,153' : color.h === 38 ? '245,158,11' : color.h === 191 ? '34,211,238' : '244,114,182'},0.06);
          border-radius: 0 6px 6px 0;
        `;
        const text = goal.text || '';
        const truncated = text.length > 120 ? text.slice(0, 120) + '...' : text;
        card.innerHTML = `
          <div style="font-size:12px;font-weight:600;color:${color.base};margin-bottom:4px;">${escapeHtml(goal.name)}</div>
          <div style="font-size:11px;color:var(--text-secondary);line-height:1.4;" class="goal-text-expandable" data-full="${escapeHtml(text)}" data-truncated="${escapeHtml(truncated)}" data-expanded="false">${escapeHtml(truncated)}</div>
        `;
        card.querySelector('.goal-text-expandable').addEventListener('click', function() {
          const expanded = this.dataset.expanded === 'true';
          this.textContent = expanded ? this.dataset.truncated : this.dataset.full;
          this.dataset.expanded = expanded ? 'false' : 'true';
          this.style.cursor = 'pointer';
        });
        card.querySelector('.goal-text-expandable').style.cursor = text.length > 120 ? 'pointer' : 'default';
        goalsContainer.appendChild(card);
      });
    }

    // Assets section
    const assetsContainer = document.getElementById('system-assets-container');
    const cats = Object.keys(state.assetsData);
    if (cats.length > 0) {
      assetsContainer.innerHTML = '';
      cats.forEach(cat => {
        const items = state.assetsData[cat];
        if (!items || items.length === 0) return;
        const section = document.createElement('div');
        section.style.marginBottom = '10px';
        section.innerHTML = `<div style="font-size:10px;text-transform:uppercase;letter-spacing:0.06em;color:var(--text-muted);margin-bottom:4px;">${escapeHtml(cat)}</div>`;
        const pillsWrap = document.createElement('div');
        pillsWrap.style.cssText = 'display:flex;flex-wrap:wrap;gap:4px;';
        items.forEach(item => {
          const pill = document.createElement('span');
          pill.style.cssText = `
            font-size:10px;padding:2px 8px;border-radius:10px;
            background:var(--bg-tertiary);color:var(--text-secondary);
            border:1px solid var(--border-subtle);
          `;
          pill.textContent = item.length > 40 ? item.slice(0, 38) + '...' : item;
          pill.title = item;
          pillsWrap.appendChild(pill);
        });
        section.appendChild(pillsWrap);
        assetsContainer.appendChild(section);
      });
    }

    // Document Flow diagram
    renderDocFlowDiagram();

    // Evolution stats — all synapses are self-mod events now
    document.getElementById('synapse-total-count').textContent = state.synapses.length;

    // Count this week's events
    const weekAgo = Date.now() - 7 * 86400000;
    const weekCount = state.synapses.filter(n => n.date && new Date(n.date).getTime() > weekAgo).length;
    document.getElementById('synapse-week-count').textContent = '+' + weekCount;

    // Evolution timeline (most recent self-modification events)
    const timelineContainer = document.getElementById('system-evolution-timeline');
    const selfMods = state.synapses.slice(-20).reverse();

    if (selfMods.length > 0) {
      timelineContainer.innerHTML = '';
      selfMods.forEach(mod => {
        const c = SYNAPSE_COLORS[mod.type] || SYNAPSE_COLORS.other;
        const entry = document.createElement('div');
        entry.style.cssText = `
          display:flex;align-items:center;gap:8px;padding:4px 0;
          border-bottom:1px solid var(--border-subtle);
          font-size:11px;
        `;
        const relTime = mod.date ? timeAgo(new Date(mod.date)) : '';
        entry.innerHTML = `
          <span style="flex-shrink:0;font-size:9px;padding:1px 6px;border-radius:8px;background:${c.glow}0.15);color:${c.base};text-transform:uppercase;font-weight:600;">${escapeHtml(mod.type)}</span>
          <span style="color:var(--text-secondary);flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${escapeHtml(mod.message)}">${escapeHtml(mod.message)}</span>
          <span style="color:var(--text-muted);font-size:10px;flex-shrink:0;">${relTime}</span>
        `;
        timelineContainer.appendChild(entry);
      });
    } else {
      timelineContainer.innerHTML = '<div style="font-size:11px;color:var(--text-muted);">No self-modification events yet</div>';
    }
  }

  function timeAgo(date) {
    const s = Math.floor((Date.now() - date.getTime()) / 1000);
    if (s < 60) return s + 's ago';
    const m = Math.floor(s / 60);
    if (m < 60) return m + 'm ago';
    const h = Math.floor(m / 60);
    if (h < 24) return h + 'h ago';
    const d = Math.floor(h / 24);
    return d + 'd ago';
  }

  function renderDocFlowDiagram() {
    const svgEl = document.getElementById('docflow-svg');
    if (!svgEl) return;
    const svg = d3.select(svgEl);
    svg.selectAll('*').remove();

    const w = 340, h = 220;
    const docs = state.documents || {};

    // Node definitions: {label, x, y, human}
    const fileNodes = [
      { id: 'GOALS', label: 'GOALS.md', x: 30, y: 30, human: true },
      { id: 'ASSETS', label: 'ASSETS.md', x: 30, y: 90, human: true },
      { id: 'STRATEGY', label: 'STRATEGY', x: 145, y: 60, human: false },
      { id: 'STATE', label: 'STATE', x: 250, y: 40, human: false },
      { id: 'OPPS', label: 'OPPS', x: 145, y: 150, human: false },
      { id: 'METRICS', label: 'METRICS', x: 250, y: 120, human: false },
      { id: 'LOG', label: 'LOG', x: 250, y: 180, human: false },
    ];

    // Connections: {from, to}
    const connections = [
      { from: 'GOALS', to: 'STRATEGY' },
      { from: 'ASSETS', to: 'STRATEGY' },
      { from: 'STRATEGY', to: 'STATE' },
      { from: 'STRATEGY', to: 'OPPS' },
      { from: 'STATE', to: 'METRICS' },
      { from: 'OPPS', to: 'STRATEGY' },
    ];

    const nodeMap = {};
    fileNodes.forEach(n => { nodeMap[n.id] = n; });

    // Draw connections with animated dots
    connections.forEach((conn, ci) => {
      const src = nodeMap[conn.from];
      const tgt = nodeMap[conn.to];
      if (!src || !tgt) return;

      svg.append('line')
        .attr('x1', src.x + 40).attr('y1', src.y + 10)
        .attr('x2', tgt.x).attr('y2', tgt.y + 10)
        .attr('stroke', 'rgba(74,158,255,0.2)')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '3,3');

      // Animated dot
      const dot = svg.append('circle').attr('r', 2).attr('fill', '#4a9eff').attr('opacity', 0.6);
      function animateDot() {
        dot.attr('cx', src.x + 40).attr('cy', src.y + 10)
          .transition().duration(2000 + ci * 500).ease(d3.easeLinear)
          .attr('cx', tgt.x).attr('cy', tgt.y + 10)
          .transition().duration(0)
          .on('end', animateDot);
      }
      animateDot();
    });

    // Draw file nodes
    fileNodes.forEach(n => {
      const docKey = n.label.replace('.md', '') + '.md';
      const meta = docs[docKey] || docs[n.label] || {};
      const isRecent = meta.mtime && (Date.now() - new Date(meta.mtime).getTime()) < 300000; // 5 min
      const fillOpacity = isRecent ? 0.15 : 0.06;
      const strokeOpacity = isRecent ? 0.6 : 0.2;

      const g = svg.append('g').attr('transform', `translate(${n.x},${n.y})`);

      g.append('rect')
        .attr('width', 75).attr('height', 22).attr('rx', 4)
        .attr('fill', `rgba(74,158,255,${fillOpacity})`)
        .attr('stroke', `rgba(74,158,255,${strokeOpacity})`)
        .attr('stroke-width', 1);

      if (isRecent) {
        g.append('rect')
          .attr('width', 75).attr('height', 22).attr('rx', 4)
          .attr('fill', 'none')
          .attr('stroke', 'rgba(74,158,255,0.4)')
          .attr('stroke-width', 1.5)
          .style('animation', 'healthPulse 2s ease-in-out infinite');
      }

      g.append('text')
        .attr('x', 37).attr('y', 14)
        .attr('text-anchor', 'middle')
        .attr('font-size', 9).attr('font-family', 'var(--font-mono)')
        .attr('fill', isRecent ? '#4a9eff' : 'var(--text-secondary)')
        .text(n.label);

      // Human badge
      if (n.human) {
        g.append('text')
          .attr('x', -4).attr('y', 6)
          .attr('font-size', 8).attr('fill', 'var(--accent-amber)')
          .text('YOU');
      }

      // mtime below
      if (meta.mtime) {
        g.append('text')
          .attr('x', 37).attr('y', 34)
          .attr('text-anchor', 'middle')
          .attr('font-size', 8).attr('fill', 'var(--text-muted)')
          .text(timeAgo(new Date(meta.mtime)));
      }
    });
  }

  function updateOpportunities(opportunities) {
    const container = document.getElementById('opportunities-container');
    if (!opportunities || opportunities.length === 0) {
      container.innerHTML = '<div style="font-size:12px;color:var(--text-muted);">No opportunities detected</div>';
      return;
    }
    container.innerHTML = '';
    opportunities.forEach(opp => {
      const item = document.createElement('div');
      item.className = 'opportunity-item';
      const badgeClass = opp.status === 'pending' ? 'pending' : opp.status === 'approved' ? 'approved' : 'rejected';
      item.innerHTML = `
        <span class="opp-badge ${badgeClass}">${escapeHtml(opp.status || 'pending')}</span>
        <span class="opp-text">${escapeHtml(opp.description || opp.text || '')}</span>
      `;
      container.appendChild(item);
    });
  }

  function updateLogs(logs) {
    const container = document.getElementById('log-container');
    if (!logs || logs.length === 0) {
      container.innerHTML = '<div style="font-size:12px;color:var(--text-muted);">No log entries</div>';
      return;
    }
    container.innerHTML = '';
    logs.slice(0, 5).forEach(log => {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `
        <div class="log-date">${escapeHtml(log.date || '')}</div>
        <div class="log-text">${escapeHtml(log.text || log.content || '')}</div>
      `;
      container.appendChild(entry);
    });
  }

  function updateAlerts(alerts) {
    const container = document.getElementById('alerts-container');
    if (!alerts || alerts.length === 0) {
      container.innerHTML = '<div style="font-size:12px;color:var(--text-muted);">No alerts</div>';
      return;
    }
    container.innerHTML = '';
    alerts.forEach(alert => {
      const item = document.createElement('div');
      item.className = 'alert-item' + (alert.critical ? ' critical' : '');
      item.innerHTML = `
        <div class="alert-title">${escapeHtml(alert.title || 'Alert')}</div>
        <div class="alert-desc">${escapeHtml(alert.description || '')}</div>
      `;
      container.appendChild(item);
    });
  }

  // ----------------------------------------------------------
  // Agent Tree Rendering
  // ----------------------------------------------------------
  const AGENT_COLORS = ['blue', 'green', 'amber', 'cyan', 'rose'];

  // Get color key for an agent — uses goal's colony color if assigned, else cycles palette
  function agentColorKey(agent, agents) {
    if (agent.goalId && state.colonies.has(agent.goalId)) {
      const colony = state.colonies.get(agent.goalId);
      return colony.colorKey || AGENT_COLORS[agents.indexOf(agent) % AGENT_COLORS.length];
    }
    return AGENT_COLORS[agents.indexOf(agent) % AGENT_COLORS.length];
  }

  function layoutAgentTree() {
    const agents = Array.from(state.agents.values());
    if (agents.length === 0) return;

    const cx = state.width / 2;
    const cy = state.height / 2;

    // Ensure all agents have initial positions (prevents 0,0 flash)
    agents.forEach(a => {
      if (a.x === undefined || a.x === 0) a.x = cx;
      if (a.y === undefined || a.y === 0) a.y = cy;
    });

    const root = agents.find(a => !a.parent);
    if (!root) {
      // Fallback: no hierarchy — distribute agents in a circle around center
      state._treeCx = cx;
      state._treeCy = cy;
      agents.forEach((a, i) => {
        const angle = (2 * Math.PI * i) / agents.length - Math.PI / 2;
        const radius = Math.min(state.width, state.height) * 0.15;
        const baseSize = i === 0 ? 40 : 28;
        const tokenBoost = a.tokens ? Math.min(12, Math.sqrt(a.tokens.total / 10000) * 3) : 0;
        a.nodeRadius = baseSize + tokenBoost;
        a._baseX = cx + Math.cos(angle) * radius;
        a._baseY = cy + Math.sin(angle) * radius;
        a.x = a.x + (a._baseX - a.x) * 0.08;
        a.y = a.y + (a._baseY - a.y) * 0.08;
      });
      return;
    }

    // Build d3 hierarchy from flat agent list
    function buildNode(agent) {
      const children = agents.filter(a => a.parent === agent.id);
      const node = { id: agent.id };
      if (children.length > 0) node.children = children.map(c => buildNode(c));
      return node;
    }

    const hierarchy = d3.hierarchy(buildNode(root));

    // Radial tree layout — spread branches around full circle
    const maxRadius = Math.min(state.width, state.height) * 0.22;
    const treeLayout = d3.tree()
      .size([2 * Math.PI, maxRadius])
      .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);

    treeLayout(hierarchy);

    // Store tree center for rendering
    state._treeCx = cx;
    state._treeCy = cy;

    // Apply computed positions to agent objects
    hierarchy.each(node => {
      const agent = state.agents.get(node.data.id);
      if (!agent) return;

      agent._angle = node.x;   // radians
      agent._radius = node.y;  // distance from center

      // Base size from hierarchy, boosted by token usage (more work = bigger)
      const baseSize = node.depth === 0 ? 40 : node.depth === 1 ? 28 : node.depth === 2 ? 20 : 16;
      const tokenBoost = agent.tokens ? Math.min(12, Math.sqrt(agent.tokens.total / 10000) * 3) : 0;
      agent.nodeRadius = baseSize + tokenBoost;

      if (node.depth === 0) {
        agent._baseX = cx;
        agent._baseY = cy;
      } else {
        // Polar to cartesian (angle 0 = top, clockwise)
        agent._baseX = cx + node.y * Math.sin(node.x);
        agent._baseY = cy - node.y * Math.cos(node.x);
      }
    });

    // Motion: drift agents toward their active goal colony
    agents.forEach(a => {
      let targetX = a._baseX, targetY = a._baseY;

      if (a.goalId && state.colonies.has(a.goalId)) {
        const colony = state.colonies.get(a.goalId);
        // Pull toward goal colony — active agents drift noticeably, idle agents lean slightly
        const pull = a.status === 'active' ? 0.3 : 0.12;
        targetX = a._baseX + (colony.cx - a._baseX) * pull;
        targetY = a._baseY + (colony.cy - a._baseY) * pull;
      }

      // Motion encoding by mode:
      if (a.status === 'active' && state.agentMode !== 'stagnating') {
        // Active: smooth gentle oscillation (working)
        const jx = Math.sin(state.time * 0.03 + a._baseX * 0.1) * 3;
        const jy = Math.cos(state.time * 0.025 + a._baseY * 0.1) * 3;
        targetX += jx;
        targetY += jy;
      } else if (state.agentMode === 'stagnating') {
        // Stagnating: high-frequency nervous jitter (stuck)
        const jx = (Math.random() - 0.5) * 1.5;
        const jy = (Math.random() - 0.5) * 1.5;
        targetX += jx;
        targetY += jy;
      }

      a._targetX = targetX;
      a._targetY = targetY;
    });

    // Collision avoidance — push overlapping nodes apart
    for (let i = 0; i < agents.length; i++) {
      for (let j = i + 1; j < agents.length; j++) {
        const a = agents[i], b = agents[j];
        const dx = a._targetX - b._targetX;
        const dy = a._targetY - b._targetY;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const minDist = (a.nodeRadius + b.nodeRadius) + 12;
        if (dist < minDist) {
          const push = (minDist - dist) * 0.5;
          const nx = dx / dist, ny = dy / dist;
          a._targetX += nx * push;
          a._targetY += ny * push;
          b._targetX -= nx * push;
          b._targetY -= ny * push;
        }
      }
    }

    // Smooth interpolation toward target (prevents jumping)
    agents.forEach(a => {
      a.x = a.x + (a._targetX - a.x) * 0.08;
      a.y = a.y + (a._targetY - a.y) * 0.08;
    });
  }

  // Quadratic bezier helpers for curved links & particle interpolation
  function computeLinkCurve(source, target) {
    const cx = state._treeCx, cy = state._treeCy;
    const mx = (source.x + target.x) / 2;
    const my = (source.y + target.y) / 2;
    // Pull control point toward center for organic tendril curves
    const pull = 0.35;
    return { cpx: mx + (cx - mx) * pull, cpy: my + (cy - my) * pull };
  }

  function bezierPoint(sx, sy, cpx, cpy, tx, ty, t) {
    const u = 1 - t;
    return { x: u*u*sx + 2*u*t*cpx + t*t*tx, y: u*u*sy + 2*u*t*cpy + t*t*ty };
  }

  function renderAgentTree() {
    const agents = Array.from(state.agents.values());
    if (agents.length === 0) {
      agentTreeLayer.selectAll('*').remove();
      if (state.liveConnected) {
        // Show empty state message in center
        const cx = state.width / 2, cy = state.height / 2;
        let emptyGroup = agentTreeLayer.select('.empty-state');
        if (emptyGroup.empty()) {
          emptyGroup = agentTreeLayer.append('g').attr('class', 'empty-state');
          emptyGroup.append('circle')
            .attr('cx', cx).attr('cy', cy).attr('r', 50)
            .attr('fill', 'none').attr('stroke', 'rgba(255,255,255,0.15)')
            .attr('stroke-width', 1.5).attr('stroke-dasharray', '6,4');
          emptyGroup.append('text')
            .attr('x', cx).attr('y', cy - 8)
            .attr('text-anchor', 'middle').attr('fill', 'rgba(255,255,255,0.4)')
            .attr('font-size', '13px').attr('font-family', 'inherit')
            .text('No active sessions');
          emptyGroup.append('text')
            .attr('x', cx).attr('y', cy + 14)
            .attr('text-anchor', 'middle').attr('fill', 'rgba(255,255,255,0.25)')
            .attr('font-size', '11px').attr('font-family', 'inherit')
            .text('Waiting for Claude Code...');
        }
      }
      return;
    }
    // Remove empty state if agents appeared
    agentTreeLayer.select('.empty-state').remove();

    layoutAgentTree();

    // System heartbeat — single expanding ring, speed reflects health
    const hbCx = state._treeCx || state.width / 2;
    const hbCy = state._treeCy || state.height / 2;
    const hbSpeed = state.health === 'green' ? 0.015 : state.health === 'yellow' ? 0.03 : 0.06;
    const hbPhase = (state.time * hbSpeed) % 1;
    const hbMaxR = Math.min(state.width, state.height) * 0.3;
    const phaseNeb = PHASE_NEBULA[state.agentPhase || 'read'] || PHASE_NEBULA.read;
    // Heartbeat color: phase-colored when healthy, shifts toward warning colors when degraded
    const hbColor = state.health === 'green' ? `${phaseNeb.r},${phaseNeb.g},${phaseNeb.b}`
      : state.health === 'yellow' ? '234,179,8' : '239,68,68';

    let hbRing = agentTreeLayer.select('.health-heartbeat');
    if (hbRing.empty()) {
      hbRing = agentTreeLayer.append('circle').attr('class', 'health-heartbeat')
        .attr('fill', 'none');
    }
    hbRing
      .attr('cx', hbCx).attr('cy', hbCy)
      .attr('r', 40 + hbPhase * hbMaxR)
      .attr('stroke', `rgba(${hbColor},${0.08 * (1 - hbPhase)})`)
      .attr('stroke-width', 1 * (1 - hbPhase));

    // Remove stale second ring if it exists
    agentTreeLayer.select('.health-heartbeat-2').remove();

    // Rate limit / rest mode indicator — dashed constraint ring
    let modeRing = agentTreeLayer.select('.mode-indicator-ring');
    if (state.agentMode === 'rate_limited' || state.agentMode === 'rest') {
      if (modeRing.empty()) {
        modeRing = agentTreeLayer.append('circle').attr('class', 'mode-indicator-ring')
          .attr('fill', 'none');
      }
      const modeColor = state.agentMode === 'rate_limited' ? '234,179,8' : '100,100,140';
      const modeAlpha = 0.15 + Math.sin(state.time * 0.02) * 0.05;
      modeRing
        .attr('cx', hbCx).attr('cy', hbCy)
        .attr('r', hbMaxR * 0.6)
        .attr('stroke', `rgba(${modeColor},${modeAlpha})`)
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,6')
        .attr('stroke-dashoffset', state.time * 0.3);
    } else {
      modeRing.remove();
    }

    // Build link data with curve control points — only for active agents
    const linkData = agents.filter(a => a.parent && state.agents.has(a.parent) && a.status === 'active').map(a => {
      const source = state.agents.get(a.parent);
      const curve = computeLinkCurve(source, a);
      return {
        source, target: a, id: a.id + '-link',
        cpx: curve.cpx, cpy: curve.cpy,
      };
    });

    // Glow halo behind links
    const glowLinks = agentTreeLayer.selectAll('.agent-link-glow').data(linkData, d => d.id + '-glow');
    glowLinks.enter().append('path').attr('class', 'agent-link-glow')
      .attr('fill', 'none')
      .merge(glowLinks)
      .attr('d', d => `M${d.source.x},${d.source.y} Q${d.cpx},${d.cpy} ${d.target.x},${d.target.y}`)
      .attr('stroke', 'rgba(180,195,220,0.08)')
      .attr('stroke-width', 8);
    glowLinks.exit().transition().duration(800).attr('stroke-opacity', 0).remove();

    // Curved path links — only visible when data flows (agent active)
    const links = agentTreeLayer.selectAll('.agent-link-path').data(linkData, d => d.id);
    links.enter().append('path').attr('class', 'agent-link-path')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        const tooltip = document.getElementById('tooltip');
        const direction = d.source.label + ' → ' + d.target.label;
        tooltip.querySelector('.tt-message').textContent = direction;
        const status = d.target.status === 'active' ? 'Active data flow' : 'Connection';
        tooltip.querySelector('.tt-meta').textContent = status;
        tooltip.querySelector('.tt-stat.add').textContent = '';
        tooltip.querySelector('.tt-stat.del').textContent = '';
        tooltip.querySelector('.tt-stat.files').textContent = '';
        tooltip.style.left = event.clientX + 12 + 'px';
        tooltip.style.top = event.clientY - 10 + 'px';
        tooltip.classList.add('visible');
      })
      .on('mouseleave', function() {
        document.getElementById('tooltip').classList.remove('visible');
      })
      .merge(links)
      .attr('d', d => `M${d.source.x},${d.source.y} Q${d.cpx},${d.cpy} ${d.target.x},${d.target.y}`)
      .attr('stroke', 'rgba(200,215,235,0.4)')
      .attr('stroke-width', 1.8)
      .attr('stroke-dasharray', '6,4');
    links.exit().transition().duration(800).attr('stroke-opacity', 0).remove();

    // Data particles flowing along curved links
    updateDataParticles(linkData);
    const dpData = state.dataParticles;
    const dps = agentTreeLayer.selectAll('.agent-data-particle').data(dpData, d => d.id);
    dps.enter().append('circle').attr('class', 'agent-data-particle').attr('r', 3)
      .merge(dps)
      .attr('cx', d => bezierPoint(d.source.x, d.source.y, d.cpx, d.cpy, d.target.x, d.target.y, d.t).x)
      .attr('cy', d => bezierPoint(d.source.x, d.source.y, d.cpx, d.cpy, d.target.x, d.target.y, d.t).y)
      .attr('fill', 'rgba(210,220,240,0.9)')
      .attr('opacity', d => 0.6 + Math.sin(d.t * Math.PI) * 0.3);
    dps.exit().remove();

    // Agent nodes
    const nodeGroups = agentTreeLayer.selectAll('.agent-node-g').data(agents, d => d.id);

    const entering = nodeGroups.enter().append('g').attr('class', 'agent-node-g')
      .style('cursor', 'pointer')
      .each(d => { d._enterTime = state.time; })
      .on('mouseenter', function(event, d) { showAgentDetail(d, event); })
      .on('mouseleave', function() { hideAgentDetail(); })
      .on('click', function(event, d) { openSidebarPanel('process'); });
    entering.append('circle').attr('class', 'agent-node-bg');
    entering.append('path').attr('class', 'agent-mode-arc').attr('fill', 'none');
    entering.append('circle').attr('class', 'agent-node-ring');
    entering.append('text').attr('class', 'agent-node-label');
    entering.append('text').attr('class', 'agent-node-action');
    entering.append('rect').attr('class', 'agent-tool-bg');
    entering.append('text').attr('class', 'agent-node-tool-badge');

    const merged = entering.merge(nodeGroups);
    // Rest/rate-limit dims all nodes
    const modeDim = state.agentMode === 'rest' ? 0.4 : state.agentMode === 'rate_limited' ? 0.7 : 1;
    const now = Date.now();
    merged.each(function(d) {
      // Smooth entrance: scale up over 30 frames
      const age = state.time - (d._enterTime || 0);
      const entranceProg = Math.min(1, age / 30);
      const eased = 1 - Math.pow(1 - entranceProg, 3); // ease-out cubic
      const scale = 0.3 + 0.7 * eased;
      // Opacity fades when agent hasn't updated recently (idle decay)
      const sinceLast = d._lastUpdate ? (now - d._lastUpdate) / 1000 : 0;
      const freshness = d.status === 'active' ? 1 : Math.max(0.35, 1 - sinceLast / 300);
      d3.select(this)
        .attr('transform', `translate(${d.x},${d.y}) scale(${scale})`)
        .attr('opacity', eased * modeDim * freshness);
    });

    // Node size breathes when active — speed modulated by system mode
    const modeBreatheMul = state.agentMode === 'rate_limited' ? 0.3
                         : state.agentMode === 'stagnating' ? 0.15
                         : state.agentMode === 'rest' ? 0.1
                         : 1;
    const breatheScale = 1 + Math.sin(state.time * 0.04 * modeBreatheMul) * 0.06;

    merged.select('.agent-node-bg')
      .attr('r', d => {
        const base = d.nodeRadius + 8;
        return d.status === 'active' ? base * breatheScale : base * 0.9;
      })
      .attr('fill', d => {
        const intensity = d.status === 'active' ? 0.08 : 0.02;
        return `rgba(200,210,230,${intensity})`;
      })
      .attr('filter', d => d.status === 'active' ? 'url(#glow-blue)' : 'none');

    merged.select('.agent-node-ring')
      .attr('r', d => {
        const base = d.nodeRadius;
        return d.status === 'active' ? base * breatheScale : base;
      })
      .attr('stroke', d => {
        const ck = agentColorKey(d, agents);
        return PALETTE[ck].base;
      })
      .attr('stroke-width', d => d.status === 'active' ? 1.8 : 1)
      .attr('stroke-opacity', d => {
        if (d.status === 'active') return 0.5 + Math.sin(state.time * 0.04) * 0.15;
        return d.status === 'done' ? 0.2 : 0.3;
      })
      .attr('fill', d => {
        const intensity = d.status === 'active' ? (0.06 + Math.sin(state.time * 0.04) * 0.02) : 0.03;
        return `rgba(180,195,220,${intensity})`;
      });

    // Mode indicator — rotating scan arc when researching (reading, searching, fetching)
    // Building needs no extra indicator — data flow particles along links already show it
    const RESEARCH_TOOLS = new Set(['Read', 'Grep', 'Glob', 'WebSearch', 'WebFetch', 'Task']);
    merged.select('.agent-mode-arc')
      .attr('d', d => {
        if (d.status !== 'active' || !d.currentTool) return '';
        if (!RESEARCH_TOOLS.has(d.currentTool)) return '';
        const r = d.nodeRadius + 4;
        // Rotating 90-degree scan arc
        const sweep = Math.PI * 0.5;
        const offset = state.time * 0.03;
        const x1 = Math.cos(offset) * r, y1 = Math.sin(offset) * r;
        const x2 = Math.cos(offset + sweep) * r, y2 = Math.sin(offset + sweep) * r;
        return `M${x1},${y1} A${r},${r} 0 0,1 ${x2},${y2}`;
      })
      .attr('stroke', 'rgba(167,139,250,0.45)')
      .attr('stroke-width', 1.5)
      .attr('stroke-linecap', 'round');

    // Agent name INSIDE the circle
    merged.select('.agent-node-label')
      .attr('y', 1)
      .attr('dominant-baseline', 'central')
      .attr('fill', d => d.status === 'active' ? 'rgba(230,235,245,0.95)' : 'rgba(200,210,225,0.7)')
      .attr('font-size', d => d.nodeRadius > 30 ? 13 : d.nodeRadius > 24 ? 11 : 9)
      .attr('opacity', 1)
      .text(d => d.label.length > 12 ? d.label.split(' ').map(w => w[0]).join('') : d.label);

    // Full name below circle — reveals on zoom
    merged.select('.agent-node-action')
      .attr('y', d => d.nodeRadius + 16)
      .attr('fill', 'var(--text-secondary)')
      .attr('font-size', 11)
      .attr('opacity', state.zoom > 1.2 ? 0.7 : 0)
      .attr('text-anchor', 'middle')
      .text(d => d.label);

    // Tool badge — show currentAction for detail (e.g. "Read: STATE.md")
    const badgeText = d => {
      if (d.currentAction && d.currentAction.length > 1) return d.currentAction;
      if (d.currentTool) return d.currentTool + '()';
      return '';
    };
    const badgeLen = d => Math.min(30, (badgeText(d) || '').length);

    // Tool badge — reveals on zoom (semantic zoom: detail increases with zoom)
    const showTools = state.zoom > 1.8;
    merged.select('.agent-tool-bg')
      .attr('opacity', showTools ? 0.8 : 0)
      .attr('x', d => -(Math.min(90, badgeLen(d) * 3.5 + 8)))
      .attr('y', d => d.nodeRadius + 26)
      .attr('width', d => Math.min(180, badgeLen(d) * 7 + 16))
      .attr('height', 16)
      .attr('rx', 4)
      .attr('fill', d => showTools && badgeText(d) ? 'rgba(34,211,238,0.08)' : 'none')
      .attr('stroke', d => showTools && badgeText(d) ? 'rgba(34,211,238,0.2)' : 'none')
      .attr('stroke-width', 0.5);

    merged.select('.agent-node-tool-badge')
      .attr('opacity', showTools ? 0.8 : 0)
      .attr('y', d => d.nodeRadius + 38)
      .attr('fill', 'var(--accent-cyan)')
      .attr('font-size', 10)
      .text(d => {
        const t = badgeText(d);
        return t.length > 28 ? t.slice(0, 26) + '...' : t;
      });

    nodeGroups.exit().transition().duration(500).attr('opacity', 0).remove();

    // Goal tendrils — only visible when agent is actively working on the goal
    const goalTendrilData = agents
      .filter(a => a.goalId && state.colonies.has(a.goalId) && a.status === 'active')
      .map(a => {
        const colony = state.colonies.get(a.goalId);
        return {
          id: a.id + '-goal',
          agent: a,
          colony,
          colorKey: colony.colorKey,
        };
      });

    // Glow halo behind goal tendrils
    const goalGlows = agentTreeLayer.selectAll('.goal-tendril-glow').data(goalTendrilData, d => d.id + '-glow');
    goalGlows.enter().append('path').attr('class', 'goal-tendril-glow')
      .attr('fill', 'none')
      .merge(goalGlows)
      .attr('d', d => {
        const ax = d.agent.x, ay = d.agent.y;
        const gx = d.colony.cx, gy = d.colony.cy;
        const mx = (ax + gx) / 2, my = (ay + gy) / 2;
        const tcx = state._treeCx, tcy = state._treeCy;
        const cpx = mx - (tcx - mx) * 0.3;
        const cpy = my - (tcy - my) * 0.3;
        return `M${ax},${ay} Q${cpx},${cpy} ${gx},${gy}`;
      })
      .attr('stroke', d => PALETTE[d.colorKey] ? PALETTE[d.colorKey].glow + '0.06)' : 'rgba(255,255,255,0.03)')
      .attr('stroke-width', 6);
    goalGlows.exit().transition().duration(1000).attr('stroke-opacity', 0).remove();

    // Visible tendril paths with animated dash flow
    const goalTendrils = agentTreeLayer.selectAll('.goal-tendril').data(goalTendrilData, d => d.id);
    goalTendrils.enter().append('path').attr('class', 'goal-tendril')
      .attr('fill', 'none')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        const tooltip = document.getElementById('tooltip');
        tooltip.querySelector('.tt-message').textContent = d.agent.label + ' → ' + (d.colony.goal.name || d.colony.id);
        const status = d.agent.status === 'active' ? 'Actively working on this goal' : 'Assigned to this goal';
        tooltip.querySelector('.tt-meta').textContent = status;
        tooltip.querySelector('.tt-stat.add').textContent = '';
        tooltip.querySelector('.tt-stat.del').textContent = '';
        tooltip.querySelector('.tt-stat.files').textContent = '';
        tooltip.style.left = event.clientX + 12 + 'px';
        tooltip.style.top = event.clientY - 10 + 'px';
        tooltip.classList.add('visible');
      })
      .on('mouseleave', function() {
        document.getElementById('tooltip').classList.remove('visible');
      })
      .merge(goalTendrils)
      .attr('d', d => {
        const ax = d.agent.x, ay = d.agent.y;
        const gx = d.colony.cx, gy = d.colony.cy;
        const mx = (ax + gx) / 2, my = (ay + gy) / 2;
        const tcx = state._treeCx, tcy = state._treeCy;
        const cpx = mx - (tcx - mx) * 0.3;
        const cpy = my - (tcy - my) * 0.3;
        return `M${ax},${ay} Q${cpx},${cpy} ${gx},${gy}`;
      })
      .attr('stroke', d => {
        const pal = PALETTE[d.colorKey];
        return pal ? pal.glow + '0.3)' : 'rgba(255,255,255,0.12)';
      })
      .attr('stroke-width', 1.5)
      .attr('stroke-dasharray', '8,12')
      .attr('stroke-dashoffset', -state.time * 0.5);
    goalTendrils.exit().transition().duration(1000).attr('stroke-opacity', 0).remove();

    // Current task label — subtle text below agent tree showing what's happening
    const taskText = state.activeTask ? state.activeTask.name || '' : '';
    let taskLabel = agentTreeLayer.select('.current-task-label');
    if (taskText && agents.length > 0) {
      if (taskLabel.empty()) {
        taskLabel = agentTreeLayer.append('text').attr('class', 'current-task-label')
          .attr('text-anchor', 'middle')
          .attr('font-family', 'var(--font-sans)')
          .attr('font-size', 11)
          .attr('pointer-events', 'none');
      }
      const root = agents.find(a => !a.parent) || agents[0];
      const maxR = Math.max(...agents.map(a => a.nodeRadius || 20));
      taskLabel
        .attr('x', hbCx)
        .attr('y', root.y + maxR + 50)
        .attr('fill', 'rgba(255,255,255,0.25)')
        .text(taskText.length > 50 ? taskText.slice(0, 48) + '...' : taskText);
    } else {
      taskLabel.remove();
    }
  }

  function updateDataParticles(linkData) {
    // Spawn new particles occasionally
    if (state.time % 20 === 0) {
      linkData.forEach(link => {
        if (link.target.status === 'active' && Math.random() > 0.5) {
          state.dataParticles.push({
            id: 'dp-' + Math.random().toString(36).slice(2),
            source: link.source,
            target: link.target,
            cpx: link.cpx, cpy: link.cpy,
            t: 0,
            speed: 0.015 + Math.random() * 0.01,
          });
        }
      });
    }
    // Advance and cull
    state.dataParticles.forEach(dp => { dp.t += dp.speed; });
    state.dataParticles = state.dataParticles.filter(dp => dp.t < 1);
  }

  function truncate(s, n) { return s.length > n ? s.slice(0, n) + '...' : s; }

  // Agent node hover detail popup
  const agentDetailEl = document.getElementById('agent-detail');

  function showAgentDetail(agent, event) {
    const det = agentDetailEl;
    document.getElementById('agent-detail-name').textContent = agent.label;

    const statusEl = document.getElementById('agent-detail-status');
    statusEl.textContent = agent.status || 'idle';
    const statusColors = { active: 'var(--accent-green)', idle: 'var(--text-muted)', done: 'var(--accent-blue)' };
    const statusBgs = { active: 'rgba(52,211,153,0.15)', idle: 'rgba(96,96,128,0.15)', done: 'rgba(74,158,255,0.15)' };
    statusEl.style.color = statusColors[agent.status] || statusColors.idle;
    statusEl.style.background = statusBgs[agent.status] || statusBgs.idle;

    // Goal assignment
    const goalEl = document.getElementById('agent-detail-goal');
    if (agent.goalId && state.colonies.has(agent.goalId)) {
      const colony = state.colonies.get(agent.goalId);
      goalEl.textContent = 'Working on: ' + (colony.goal.name || agent.goalId);
      goalEl.style.color = colony.color.base;
    } else {
      goalEl.textContent = '';
      goalEl.style.color = '';
    }

    document.getElementById('agent-detail-action').textContent = agent.currentAction || 'Idle';
    document.getElementById('agent-detail-tool').textContent = agent.currentTool ? agent.currentTool + '()' : 'No active tool';

    // Model info
    const modelEl = document.getElementById('agent-detail-model');
    modelEl.textContent = agent.model ? agent.model.replace('claude-', '').replace('-20251001', '').replace('-20250929', '') : '';

    const tok = agent.tokens;
    document.getElementById('agent-detail-tokens').textContent = tok
      ? `${(tok.total / 1000).toFixed(1)}K tokens (${(tok.input / 1000).toFixed(1)}K in / ${(tok.output / 1000).toFixed(1)}K out)`
      : '';

    // Position relative to the node — offset to the right
    const rect = document.getElementById('main-viz').getBoundingClientRect();
    const transform = d3.zoomTransform(d3.select('#main-viz').node());
    const screenX = transform.applyX(agent.x) + rect.left;
    const screenY = transform.applyY(agent.y) + rect.top;

    let left = screenX + agent.nodeRadius + 16;
    let top = screenY - 40;

    // Keep on screen
    if (left + 270 > window.innerWidth) left = screenX - 280;
    if (top < 60) top = 60;
    if (top + 160 > window.innerHeight) top = window.innerHeight - 170;

    det.style.left = left + 'px';
    det.style.top = top + 'px';
    det.classList.add('visible');
  }

  function hideAgentDetail() {
    agentDetailEl.classList.remove('visible');
  }

  // ----------------------------------------------------------
  // Context Meter
  // ----------------------------------------------------------
  function updateContextMeter() {
    const ctx = state.context;
    const total = ctx.system + ctx.conversation + ctx.tools + ctx.thinking;
    const max = ctx.max;
    const pct = (v) => (v / max * 100).toFixed(1) + '%';

    // HUD compact bar
    document.getElementById('ctx-system').style.width = pct(ctx.system);
    document.getElementById('ctx-conversation').style.width = pct(ctx.conversation);
    document.getElementById('ctx-tools').style.width = pct(ctx.tools);
    document.getElementById('ctx-thinking').style.width = pct(ctx.thinking);
    document.getElementById('ctx-label').textContent = Math.round(total / 1000) + 'K / ' + Math.round(max / 1000) + 'K';

    // Sidebar large bar
    const lg = (id, v) => { const el = document.getElementById(id); if (el) el.style.width = pct(v); };
    lg('ctx-lg-system', ctx.system);
    lg('ctx-lg-conversation', ctx.conversation);
    lg('ctx-lg-tools', ctx.tools);
    lg('ctx-lg-thinking', ctx.thinking);

    const pctEl = document.getElementById('ctx-pct');
    if (pctEl) pctEl.textContent = Math.round(total / max * 100) + '% — ' + Math.round(total / 1000) + 'K tokens';
  }

  // ----------------------------------------------------------
  // Process Panel
  // ----------------------------------------------------------
  function updatePhaseIndicator() {
    const phases = ['read', 'decide', 'execute', 'verify'];
    const phaseLabels = { read: 'READ', decide: 'DECIDE', execute: 'EXEC', verify: 'VERIFY' };
    const currentIdx = phases.indexOf(state.agentPhase);

    // Sidebar phase track
    document.querySelectorAll('#phase-track .phase-step').forEach(el => {
      const phase = el.dataset.phase;
      const idx = phases.indexOf(phase);
      el.className = 'phase-step ' + (idx < currentIdx ? 'done' : idx === currentIdx ? 'active' : 'pending');
    });

    // HUD phase indicator
    document.querySelectorAll('#hud-phase .hud-phase-step').forEach(el => {
      const phase = el.dataset.phase;
      const idx = phases.indexOf(phase);
      el.className = 'hud-phase-step ' + (idx < currentIdx ? 'done' : idx === currentIdx ? 'active' : 'pending');
    });
    const hudLabel = document.getElementById('hud-phase-label');
    if (hudLabel) hudLabel.textContent = phaseLabels[state.agentPhase] || '--';

    // Mission Status phase badge
    const badge = document.getElementById('mission-phase-badge');
    if (badge) {
      badge.className = 'mission-phase-badge ' + state.agentPhase;
      badge.id = 'mission-phase-badge';
      badge.textContent = phaseLabels[state.agentPhase] || '--';
    }
  }

  function updateAgentCards() {
    const container = document.getElementById('agent-cards-container');
    if (!container) return;
    const agents = Array.from(state.agents.values());
    if (agents.length === 0) {
      container.innerHTML = '<div style="font-size:12px;color:var(--text-muted);">No agents active</div>';
      return;
    }
    container.innerHTML = '';
    agents.forEach((agent, i) => {
      const ck = AGENT_COLORS[i % AGENT_COLORS.length];
      const color = PALETTE[ck];
      const tokenPct = agent.tokens ? Math.round(agent.tokens.total / state.context.max * 100) : 0;
      const card = document.createElement('div');
      card.className = 'agent-card';
      card.innerHTML = `
        <div class="agent-card-header">
          <span class="agent-card-dot" style="background:${color.base}"></span>
          <span class="agent-card-name">${escapeHtml(agent.label)}</span>
          <span class="agent-card-status">${escapeHtml(agent.status)}</span>
        </div>
        <div class="agent-card-action">${escapeHtml(agent.currentAction || 'Idle')}</div>
        <div class="agent-card-tokens">${agent.tokens ? Math.round(agent.tokens.total / 1000) + 'K tokens' : '--'}${agent.model ? ' · ' + escapeHtml(agent.model.replace('claude-', '').replace('-20251001', '')) : ''}</div>
        <div class="agent-card-bar"><div class="agent-card-fill" style="width:${tokenPct}%;background:${color.base}"></div></div>
        ${(agent.recentTools && agent.recentTools.length > 1) ? '<div class="agent-card-recent" style="margin-top:4px;font-size:10px;color:var(--text-muted);line-height:1.4;">' + agent.recentTools.slice(-5).map(t => '<div style="opacity:' + (t === agent.currentAction ? '1' : '0.5') + '">· ' + escapeHtml(t.length > 40 ? t.slice(0,38) + '...' : t) + '</div>').join('') + '</div>' : ''}
      `;
      container.appendChild(card);
    });
  }

  function updateToolCalls() {
    const container = document.getElementById('tool-calls-container');
    if (!container) return;
    const calls = state.toolCalls;
    if (calls.length === 0) {
      container.innerHTML = '<div style="font-size:12px;color:var(--text-muted);">No tool calls</div>';
      return;
    }
    container.innerHTML = '';
    // Show most recent first
    calls.slice().reverse().slice(0, 20).forEach(tc => {
      const agent = state.agents.get(tc.agent);
      const agentIdx = Array.from(state.agents.keys()).indexOf(tc.agent);
      const ck = AGENT_COLORS[Math.max(0, agentIdx) % AGENT_COLORS.length];
      const color = PALETTE[ck] || PALETTE.blue;
      const item = document.createElement('div');
      item.className = 'tool-call-item';
      item.innerHTML = `
        <span class="tool-agent-dot" style="background:${color.base}"></span>
        <span class="tool-name">${escapeHtml(tc.tool)}</span>
        <span class="tool-target">${escapeHtml(tc.target || '')}</span>
        <span class="tool-status ${tc.status}">${tc.status}</span>
        <span class="tool-duration">${tc.duration ? tc.duration + 'ms' : '...'}</span>
      `;
      container.appendChild(item);
    });
  }

  // ----------------------------------------------------------
  // Thinking Panel
  // ----------------------------------------------------------
  function updateThinkingPanel() {
    const container = document.getElementById('thinking-container');
    if (!container) return;
    const steps = state.thinkingSteps;
    if (steps.length === 0) {
      container.innerHTML = '<div style="font-size:12px;color:var(--text-muted);">No thinking data yet</div>';
      return;
    }
    container.innerHTML = '';
    steps.forEach(step => {
      const el = document.createElement('div');
      el.className = 'thinking-step' + (step.status === 'active' ? ' active' : '');
      el.innerHTML = `
        <span class="thinking-phase ${step.phase.toLowerCase()}">${escapeHtml(step.phase)}</span>
        <div class="thinking-content">
          <div class="thinking-text">${escapeHtml(step.text)}</div>
          <div class="thinking-time">${escapeHtml(step.time || '')}</div>
        </div>
      `;
      container.appendChild(el);
    });
    container.scrollTop = container.scrollHeight;
  }

  // ----------------------------------------------------------
  // Mission Status Panel
  // ----------------------------------------------------------
  function updateMissionStatus() {
    // Phase badge (already handled by updatePhaseIndicator)

    // Current task
    if (state.activeTask) {
      const t = state.activeTask;
      const colony = state.colonies.get(t.goalId);
      const goalBadge = document.getElementById('mission-goal-badge');
      if (goalBadge) {
        goalBadge.textContent = t.goalName || t.goalId || 'Agent';
        if (colony) {
          goalBadge.style.background = colony.color.dim;
          goalBadge.style.color = colony.color.base;
        }
      }
      const taskName = document.getElementById('mission-task-name');
      if (taskName) taskName.textContent = t.name || 'Working...';
      const taskDetail = document.getElementById('mission-task-detail');
      if (taskDetail) taskDetail.textContent = t.status || '';
    }

    // Agent count + pips
    const agentsRow = document.getElementById('mission-agents-row');
    if (agentsRow) {
      const agents = Array.from(state.agents.values());
      agentsRow.innerHTML = '';
      agents.forEach((agent, i) => {
        const ck = AGENT_COLORS[i % AGENT_COLORS.length];
        const color = PALETTE[ck];
        const pip = document.createElement('span');
        pip.className = 'mission-agent-pip' + (agent.status === 'active' ? ' active' : '');
        pip.style.background = color.base;
        pip.style.borderColor = color.glow + '0.5)';
        pip.title = agent.label + ' (' + agent.status + ')';
        agentsRow.appendChild(pip);
      });
      const count = document.createElement('span');
      count.id = 'mission-agent-count';
      count.textContent = agents.length + ' agent' + (agents.length !== 1 ? 's' : '') + ' active';
      agentsRow.appendChild(count);
    }

    // Latest thinking
    if (state.thinkingSteps.length > 0) {
      const latest = state.thinkingSteps[state.thinkingSteps.length - 1];
      const thinkText = document.getElementById('mission-thinking-text');
      const thinkTime = document.getElementById('mission-thinking-time');
      if (thinkText) thinkText.textContent = latest.text;
      if (thinkTime) thinkTime.textContent = latest.time || '';
    }
  }

  // ----------------------------------------------------------
  // Thinking Ticker (always visible)
  // ----------------------------------------------------------
  function updateThinkingTicker() {
    const container = document.getElementById('thinking-ticker-entries');
    if (!container) return;
    const steps = state.thinkingSteps;
    if (steps.length === 0) {
      container.innerHTML = '<div style="font-size:11px;color:var(--text-muted);padding:8px 0;">Waiting for agent reasoning...</div>';
      return;
    }

    // Show last 5 steps
    const recent = steps.slice(-5);
    container.innerHTML = '';
    recent.forEach(step => {
      const entry = document.createElement('div');
      entry.className = 'ticker-entry';
      entry.innerHTML = `
        <span class="ticker-phase ${step.phase.toLowerCase()}">${escapeHtml(step.phase)}</span>
        <span class="ticker-text">${escapeHtml(step.text)}</span>
        <span class="ticker-time">${escapeHtml(step.time || '')}</span>
      `;
      container.appendChild(entry);
    });
    container.scrollTop = container.scrollHeight;
  }

  // ----------------------------------------------------------
  // SSE Connection
  // ----------------------------------------------------------
  // Configurable API base: ?api=http://localhost:3001 or defaults to same-origin
  const API_BASE = new URLSearchParams(location.search).get('api') || '';
  let sseRetryDelay = 1000;
  let sseRetryMax = 30000;
  let eventSource = null;

  function connectSSE() {
    const connDot = document.getElementById('conn-dot');
    const connText = document.getElementById('conn-text');

    connDot.className = 'connecting';
    connText.textContent = 'connecting' + (API_BASE ? ` to ${API_BASE}` : '');

    try {
      eventSource = new EventSource(API_BASE + '/api/stream');

      eventSource.onopen = () => {
        sseRetryDelay = 1000;
        connDot.className = '';
        connText.textContent = 'connected';
        if (!state.liveConnected) {
          state.liveConnected = true;
          // Clear demo data — real server will push live state
          state.agents.clear();
          state.toolCalls = [];
          state.thinkingSteps = [];
          renderAgentTree();
          updateAgentCards();
          updateToolCalls();
          updateThinkingTicker();
          updateMissionStatus();
        }
      };

      eventSource.onerror = () => {
        eventSource.close();
        connDot.className = 'disconnected';
        connText.textContent = 'reconnecting';
        setTimeout(connectSSE, sseRetryDelay);
        sseRetryDelay = Math.min(sseRetryDelay * 1.5, sseRetryMax);
      };

      // SSE event handlers
      eventSource.addEventListener('agent_status', (e) => {
        try {
          const data = JSON.parse(e.data);
          handleAgentStatus(data);
          addFeedEntry('agent_status', 'Agent: ' + (data.status || modeLabel(data.mode || 'active')));
        } catch(err) { console.warn('SSE parse error:', err); }
      });

      eventSource.addEventListener('stagnation', (e) => {
        try {
          const data = JSON.parse(e.data);
          state.agentMode = 'stagnating';
          state.health = 'yellow';
          state.statusText = data.message || 'Stagnation detected';
          updateHealthUI();
          addFeedEntry('stagnation', data.message || 'Stagnation detected');
        } catch(err) {}
      });

      eventSource.addEventListener('heartbeat', (e) => {
        try {
          const data = JSON.parse(e.data);
          state.lastHeartbeat = data.timestamp || new Date().toISOString();
          const hbEl = document.getElementById('heartbeat-display');
          if (hbEl) hbEl.textContent = 'Last heartbeat: ' + formatTime(state.lastHeartbeat);
          addFeedEntry('heartbeat', 'Heartbeat received');
        } catch(err) {}
      });

      eventSource.addEventListener('git_activity', (e) => {
        try {
          const data = JSON.parse(e.data);
          handleGitActivity(data);
        } catch(err) {}
      });

      eventSource.addEventListener('daydream', (e) => {
        try {
          const data = JSON.parse(e.data);
          handleDaydream(data);
        } catch(err) {}
      });

      eventSource.addEventListener('opportunities', (e) => {
        try {
          const data = JSON.parse(e.data);
          updateOpportunities(data.items || data);
          const sections = data.sections || data.items || data;
          if (Array.isArray(sections) && sections.length > 0) {
            addFeedEntry('opportunity', 'Opportunities updated (' + sections.length + ' items)');
          }
        } catch(err) {}
      });

      eventSource.addEventListener('metrics', (e) => {
        try {
          const data = JSON.parse(e.data);
          Object.assign(state.metrics, data);
          updateSidebarOverview();
          addFeedEntry('metrics', 'Metrics updated');
        } catch(err) {}
      });

      eventSource.addEventListener('state', (e) => {
        try {
          const data = JSON.parse(e.data);
          document.getElementById('raw-state').textContent = data.content || JSON.stringify(data, null, 2);
          addFeedEntry('state', 'State file updated');
        } catch(err) {}
      });

      eventSource.addEventListener('log', (e) => {
        try {
          const data = JSON.parse(e.data);
          updateLogs(data.entries || [data]);
          const entries = data.entries || [data];
          if (entries.length > 0) {
            addFeedEntry('log', entries[0].text || entries[0].content || 'Log updated');
          }
        } catch(err) {}
      });

      eventSource.addEventListener('strategy', (e) => {
        try {
          const data = JSON.parse(e.data);
          document.getElementById('raw-strategy').textContent = data.content || JSON.stringify(data, null, 2);
          addFeedEntry('strategy', 'Strategy updated');
        } catch(err) {}
      });

      eventSource.addEventListener('context_usage', (e) => {
        try {
          const data = JSON.parse(e.data);
          Object.assign(state.context, data);
          updateContextMeter();
        } catch(err) {}
      });

      eventSource.addEventListener('agent_tree', (e) => {
        try {
          const data = JSON.parse(e.data);
          if (data.agents) {
            state.agents.clear();
            const cx = state.width / 2, cy = state.height / 2;
            data.agents.forEach(a => {
              // Ensure agents have valid positions (prevents 0,0 overlap)
              if (!a.x || a.x === 0) a.x = cx;
              if (!a.y || a.y === 0) a.y = cy;
              a._lastUpdate = Date.now();
              state.agents.set(a.id, a);
            });
            renderAgentTree();
            updateAgentCards();
            // Update HUD status based on session count
            const sessionCount = data.agents.filter(a => !a.parent).length;
            if (sessionCount === 0) {
              state.statusText = 'No active sessions';
              state.health = 'yellow';
            } else {
              state.statusText = sessionCount + ' session' + (sessionCount !== 1 ? 's' : '') + ' active';
              state.health = 'green';
            }
            updateHealthUI();
          }
          if (data.phase) {
            state.agentPhase = data.phase;
            updatePhaseIndicator();
          }
          updateMissionStatus();
          addFeedEntry('agent_status', 'Agent tree updated (' + state.agents.size + ' agents)');
        } catch(err) {}
      });

      eventSource.addEventListener('daily_usage', (e) => {
        try {
          const data = JSON.parse(e.data);
          const el = document.getElementById('hud-usage');
          if (el && typeof data.total === 'number') {
            const t = data.total;
            el.textContent = t >= 1e6 ? (t / 1e6).toFixed(1) + 'M' : t >= 1e3 ? (t / 1e3).toFixed(0) + 'K' : String(t);
            el.title = `Input: ${(data.input/1e6).toFixed(2)}M | Output: ${(data.output/1e6).toFixed(2)}M | Sessions: ${data.sessions}`;
          }
        } catch(err) {}
      });

      eventSource.addEventListener('tool_call', (e) => {
        try {
          const data = JSON.parse(e.data);
          if (data.id) {
            const existing = state.toolCalls.find(tc => tc.id === data.id);
            if (existing) Object.assign(existing, data);
            else state.toolCalls.push(data);
          }
          if (state.toolCalls.length > 30) state.toolCalls = state.toolCalls.slice(-25);
          updateToolCalls();
        } catch(err) {}
      });

      eventSource.addEventListener('thinking', (e) => {
        try {
          const data = JSON.parse(e.data);
          state.thinkingSteps.forEach(s => { if (s.status === 'active') s.status = 'done'; });
          state.thinkingSteps.push({
            phase: data.phase || 'EXECUTE',
            text: data.text || '',
            status: 'active',
            time: data.time || new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' }),
          });
          if (state.thinkingSteps.length > 20) state.thinkingSteps = state.thinkingSteps.slice(-15);
          updateThinkingPanel();
          updateThinkingTicker();
          updateMissionStatus();
        } catch(err) {}
      });

      // Goals & Assets file updates
      eventSource.addEventListener('goals_full', (e) => {
        try {
          const data = JSON.parse(e.data);
          if (Array.isArray(data)) state.goalsText = data;
          updateSystemPanel();
        } catch(err) {}
      });

      eventSource.addEventListener('assets_full', (e) => {
        try {
          const data = JSON.parse(e.data);
          if (data && typeof data === 'object') state.assetsData = data;
          updateSystemPanel();
        } catch(err) {}
      });

      // Generic message handler
      eventSource.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          if (data.type) {
            handleGenericEvent(data);
          }
        } catch(err) {}
      };

    } catch (err) {
      connDot.className = 'disconnected';
      connText.textContent = 'error';
      setTimeout(connectSSE, sseRetryDelay);
      sseRetryDelay = Math.min(sseRetryDelay * 1.5, sseRetryMax);
    }
  }

  // ----------------------------------------------------------
  // Event Handlers
  // ----------------------------------------------------------
  function handleAgentStatus(data) {
    state.agentMode = data.mode || 'active';
    state.health = data.health || 'green';
    state.statusText = data.status || modeLabel(state.agentMode);

    if (data.activeGoal) {
      state.activeGoal = data.activeGoal;
      state.colonies.forEach(c => { c.active = (c.id === data.activeGoal); });
    }

    if (data.activeTask) {
      state.activeTask = data.activeTask;
    }

    updateHealthUI();
    updateSidebarOverview();
    updateMissionStatus();
  }

  function handleGitActivity(data) {
    const commits = Array.isArray(data) ? data : data.commits || [data];
    commits.forEach(commit => {
      const goalId = commit.goalId || commit.goal;
      const colony = state.colonies.get(goalId);
      if (!colony) return;

      const particle = new Particle(commit, colony);
      colony.particles.push(particle);
      colony.radius = Math.min(180, 60 + colony.particles.length * 1.5);
    });
  }

  function handleDaydream(data) {
    const links = data.links || data.connections || [];
    links.forEach(link => {
      const sourceColony = state.colonies.get(link.sourceGoal || link.from);
      const targetColony = state.colonies.get(link.targetGoal || link.to);
      if (!sourceColony || !targetColony) return;

      const sourceP = sourceColony.particles[Math.floor(Math.random() * sourceColony.particles.length)];
      const targetP = targetColony.particles[Math.floor(Math.random() * targetColony.particles.length)];
      if (!sourceP || !targetP) return;

      state.daydreamLinks.push({
        id: link.id || Math.random().toString(36).slice(2),
        source: sourceP,
        target: targetP,
        hit: link.hit || false,
        opportunity: link.opportunity || false,
        birth: state.time,
      });
    });

    // Cap link count
    if (state.daydreamLinks.length > 100) {
      state.daydreamLinks = state.daydreamLinks.slice(-80);
    }
  }

  function handleGenericEvent(data) {
    switch(data.type) {
      case 'agent_status': handleAgentStatus(data); break;
      case 'git_activity': handleGitActivity(data); break;
      case 'daydream': handleDaydream(data); break;
      case 'heartbeat':
        state.lastHeartbeat = data.timestamp || new Date().toISOString();
        const hbDisplay = document.getElementById('heartbeat-display');
        if (hbDisplay) hbDisplay.textContent = 'Last heartbeat: ' + formatTime(state.lastHeartbeat);
        addFeedEntry('heartbeat', 'Heartbeat received');
        break;
      case 'metrics':
        Object.assign(state.metrics, data);
        updateSidebarOverview();
        break;
    }
  }

  // ----------------------------------------------------------
  // API Initial Loads
  // ----------------------------------------------------------
  async function loadInitialData() {
    const endpoints = [
      { url: '/api/state', handler: handleStateResponse },
      { url: '/api/git', handler: handleGitResponse },
      { url: '/api/daydream', handler: handleDaydreamResponse },
      { url: '/api/security', handler: handleSecurityResponse },
      { url: '/api/architecture', handler: handleArchitectureResponse },
    ];

    let anySuccess = false;
    for (const ep of endpoints) {
      try {
        const res = await fetch(ep.url);
        if (res.ok) {
          anySuccess = true;
          const data = await res.json();
          ep.handler(data);
        }
      } catch (err) {
        console.log(`API ${ep.url} not available, using demo data`);
      }
    }

    // Only seed demo data if NO API endpoint responded (fully offline)
    if (!anySuccess && state.goals.length === 0) {
      seedDemoData();
    }

    layoutColonies();
    updateSidebarOverview();
    updateGoalsPanel();
    updateSystemPanel();
    updateMissionStatus();
    updateThinkingTicker();
  }

  function handleStateResponse(data) {
    if (data.goals) {
      state.goals = data.goals;
    }
    if (data.health) state.health = data.health;
    if (data.status) state.statusText = data.status;
    if (data.mode) state.agentMode = data.mode;
    if (data.activeGoal) state.activeGoal = data.activeGoal;
    if (data.activeTask) state.activeTask = data.activeTask;
    if (data.metrics) Object.assign(state.metrics, data.metrics);
    if (data.logs) updateLogs(data.logs);
    if (data.alerts) updateAlerts(data.alerts);
    if (data.raw) {
      if (data.raw.state) document.getElementById('raw-state').textContent = data.raw.state;
      if (data.raw.strategy) document.getElementById('raw-strategy').textContent = data.raw.strategy;
    }
    updateHealthUI();
  }

  function handleGitResponse(data) {
    const commits = data.commits || data;
    if (!Array.isArray(commits)) return;
    handleGitActivity(commits);
    // Synapse tree is now initialized from /api/architecture synapses, not all commits
  }

  function handleDaydreamResponse(data) {
    if (data.links || data.connections) {
      handleDaydream(data);
    }
    if (data.opportunities) {
      updateOpportunities(data.opportunities);
    }
  }

  function handleSecurityResponse(data) {
    document.getElementById('raw-security').textContent = data.content || JSON.stringify(data, null, 2);
  }

  function handleArchitectureResponse(data) {
    if (data.goals && Array.isArray(data.goals)) {
      state.goalsText = data.goals;
    }
    if (data.assets && typeof data.assets === 'object') {
      state.assetsData = data.assets;
    }
    if (data.documents) {
      state.documents = data.documents;
    }
    if (data.reviewCycles) {
      state.reviewStatus = data.reviewCycles;
    }
    // Initialize synapse tree from self-modification events
    if (data.synapses && data.synapses.length > 0 && state.synapses.length === 0) {
      initSynapseTree(data.synapses);
    }
    updateSystemPanel();
  }

  // ----------------------------------------------------------
  // Demo Data (when API is unavailable)
  // ----------------------------------------------------------
  function seedDemoData() {
    state.goals = [
      { id: 'revenue', name: 'Revenue Generation', progress: 34, commits7d: 18 },
      { id: 'audience', name: 'Audience Growth', progress: 52, commits7d: 24 },
      { id: 'skills', name: 'Skill Acquisition', progress: 68, commits7d: 12 },
      { id: 'infrastructure', name: 'Infrastructure', progress: 81, commits7d: 31 },
      { id: 'research', name: 'Research & Exploration', progress: 22, commits7d: 8 },
    ];

    state.activeGoal = 'audience';
    state.agentMode = 'active';
    state.health = 'green';
    state.statusText = 'Active - writing content pipeline';
    state.lastHeartbeat = new Date().toISOString();
    state.metrics = {
      revenue: '$1,247',
      views: 14832,
      tasksPerWeek: 47,
      skills: 12,
      daydreamHitRate: 23,
    };
    state.activeTask = {
      goalId: 'audience',
      goalName: 'Audience Growth',
      name: 'Generate blog post on cross-domain AI applications',
      status: 'writing draft',
    };

    layoutColonies();

    // Seed particles
    const commitTypes = ['feat', 'fix', 'refactor', 'docs', 'research', 'skill', 'state', 'chore'];
    const messages = [
      'Add RSS feed parser for content aggregation',
      'Fix authentication token refresh logic',
      'Implement A/B testing framework for headlines',
      'Research vector embedding strategies',
      'Update skill tree with new SEO capabilities',
      'Refactor content pipeline for parallel processing',
      'Add analytics tracking to landing pages',
      'Fix rate limiter edge case on burst traffic',
      'Document API endpoints for content service',
      'Implement cross-domain linking for daydream module',
      'Add monitoring alerts for revenue thresholds',
      'Optimize database queries for audience metrics',
      'Build automated social media posting pipeline',
      'Research competitor content strategies',
      'Implement retry logic for external API calls',
      'Add error handling for payment webhook processing',
      'Update infrastructure terraform modules',
      'Refactor state management for goal tracking',
      'Fix timezone bug in scheduling system',
      'Add skill assessment benchmarking suite',
    ];

    state.goals.forEach(goal => {
      const colony = state.colonies.get(goal.id);
      if (!colony) return;
      colony.active = (goal.id === state.activeGoal);

      const numParticles = 8 + Math.floor(Math.random() * 15);
      for (let i = 0; i < numParticles; i++) {
        const commit = {
          hash: Math.random().toString(36).slice(2, 9),
          message: messages[Math.floor(Math.random() * messages.length)],
          timestamp: new Date(Date.now() - Math.random() * 7 * 86400000).toISOString(),
          type: commitTypes[Math.floor(Math.random() * commitTypes.length)],
          filesChanged: Math.floor(Math.random() * 8) + 1,
          additions: Math.floor(Math.random() * 200),
          deletions: Math.floor(Math.random() * 80),
          age: Math.floor(Math.random() * 60),
          isActive: false,
        };
        // Make one particle in the active colony the active task
        if (colony.active && i === numParticles - 1) {
          commit.isActive = true;
          commit.message = state.activeTask.name;
          commit.age = 0;
        }
        const particle = new Particle(commit, colony);
        colony.particles.push(particle);
      }

      colony.radius = Math.min(160, 60 + colony.particles.length * 1.5);
    });

    // Seed daydream links — stagger birth times so they don't all expire at once
    const colonyArr = Array.from(state.colonies.values());
    for (let i = 0; i < 6; i++) {
      const ci = Math.floor(Math.random() * colonyArr.length);
      let cj = Math.floor(Math.random() * colonyArr.length);
      if (ci === cj) cj = (ci + 1) % colonyArr.length;
      const src = colonyArr[ci];
      const tgt = colonyArr[cj];
      if (src.particles.length === 0 || tgt.particles.length === 0) continue;
      const sp = src.particles[Math.floor(Math.random() * src.particles.length)];
      const tp = tgt.particles[Math.floor(Math.random() * tgt.particles.length)];
      state.daydreamLinks.push({
        id: 'dd-' + i,
        source: sp,
        target: tp,
        hit: Math.random() > 0.5,
        opportunity: Math.random() > 0.6,
        birth: state.time - i * 25,
      });
    }

    // Seed sidebar data
    updateAlerts([
      { title: 'Pending Approval', description: 'Cross-domain content opportunity: link revenue SEO insights to audience growth blog posts', critical: false },
      { title: 'Stagnation Warning', description: 'Research goal has had no commits in 48 hours', critical: false },
    ]);

    updateLogs([
      { date: '2026-02-12', text: 'Published blog post on AI-assisted content creation. Engagement metrics look promising with 340 views in first hour.' },
      { date: '2026-02-11', text: 'Completed infrastructure migration to edge workers. Latency reduced by 62%. Revenue endpoints now respond in <50ms.' },
      { date: '2026-02-10', text: 'Daydream module identified cross-domain opportunity: research findings on embeddings can improve audience content recommendations.' },
    ]);

    updateOpportunities([
      { status: 'pending', description: 'Apply revenue optimization insights to audience targeting algorithm' },
      { status: 'approved', description: 'Use infrastructure caching layer for research data retrieval' },
      { status: 'pending', description: 'Cross-pollinate skill assessment metrics into content quality scoring' },
    ]);

    document.getElementById('raw-state').textContent = `# Agent State
Mode: active
Health: green
Current Goal: audience
Current Task: Generate blog post on cross-domain AI applications
Uptime: 72h 14m
Goals: 5 active
Commits (7d): 93
Daydream Links: 14 active (6 hits, 8 misses)`;

    document.getElementById('raw-strategy').textContent = `# Strategy
## Priority Order
1. Audience Growth (high momentum, capitalize)
2. Infrastructure (stability enables all goals)
3. Revenue Generation (needs audience base first)
4. Skill Acquisition (ongoing background)
5. Research (explore when idle)

## Current Focus
Content pipeline producing 2-3 posts/day.
A/B testing headlines for CTR optimization.
Cross-domain insights feeding content topics.`;

    document.getElementById('raw-security').textContent = `# Security Report
Last scan: 2026-02-12T08:00:00Z
Status: CLEAN

Dependencies: 0 critical, 1 moderate
API Keys: rotated 2026-02-10
Rate Limits: active, no violations
Auth: tokens refreshed, no anomalies`;

    // Seed agent tree — branching hierarchy with goal associations
    state.agents.set('strategist', {
      id: 'strategist', label: 'Strategist', parent: null,
      status: 'active', currentTool: 'Task', goalId: 'audience',
      currentAction: 'Coordinating content pipeline',
      tokens: { input: 45200, output: 12800, total: 58000 },
      nodeRadius: 30,
    });
    state.agents.set('content-writer', {
      id: 'content-writer', label: 'Content Writer', parent: 'strategist',
      status: 'active', currentTool: 'Write', goalId: 'audience',
      currentAction: 'Drafting blog post on AI applications',
      tokens: { input: 22000, output: 8500, total: 30500 },
      nodeRadius: 22,
    });
    state.agents.set('blog-drafter', {
      id: 'blog-drafter', label: 'Blog Drafter', parent: 'content-writer',
      status: 'active', currentTool: 'Write', goalId: 'audience',
      currentAction: 'Writing intro section',
      tokens: { input: 6000, output: 3200, total: 9200 },
      nodeRadius: 16,
    });
    state.agents.set('seo-optimizer', {
      id: 'seo-optimizer', label: 'SEO Optimizer', parent: 'content-writer',
      status: 'active', currentTool: 'Grep', goalId: 'audience',
      currentAction: 'Analyzing keyword density',
      tokens: { input: 4800, output: 1600, total: 6400 },
      nodeRadius: 16,
    });
    state.agents.set('research-scout', {
      id: 'research-scout', label: 'Research Scout', parent: 'strategist',
      status: 'active', currentTool: 'WebSearch', goalId: 'research',
      currentAction: 'Searching competitor strategies',
      tokens: { input: 15000, output: 4200, total: 19200 },
      nodeRadius: 22,
    });
    state.agents.set('deep-researcher', {
      id: 'deep-researcher', label: 'Deep Researcher', parent: 'research-scout',
      status: 'active', currentTool: 'Read', goalId: 'research',
      currentAction: 'Reading embedding analysis paper',
      tokens: { input: 8000, output: 2100, total: 10100 },
      nodeRadius: 16,
    });
    state.agents.set('trend-analyzer', {
      id: 'trend-analyzer', label: 'Trend Analyzer', parent: 'research-scout',
      status: 'active', currentTool: 'WebFetch', goalId: 'research',
      currentAction: 'Fetching trending topics API',
      tokens: { input: 5200, output: 1800, total: 7000 },
      nodeRadius: 16,
    });
    state.agents.set('code-engineer', {
      id: 'code-engineer', label: 'Code Engineer', parent: 'strategist',
      status: 'active', currentTool: 'Edit', goalId: 'infrastructure',
      currentAction: 'Implementing RSS parser',
      tokens: { input: 18000, output: 9200, total: 27200 },
      nodeRadius: 22,
    });
    state.agents.set('test-runner', {
      id: 'test-runner', label: 'Test Runner', parent: 'code-engineer',
      status: 'active', currentTool: 'Bash', goalId: 'infrastructure',
      currentAction: 'Running integration tests',
      tokens: { input: 3200, output: 800, total: 4000 },
      nodeRadius: 16,
    });
    state.agents.set('data-analyst', {
      id: 'data-analyst', label: 'Data Analyst', parent: 'strategist',
      status: 'active', currentTool: 'Read', goalId: 'revenue',
      currentAction: 'Analyzing engagement metrics',
      tokens: { input: 11000, output: 3400, total: 14400 },
      nodeRadius: 22,
    });

    // Seed context usage
    state.context = {
      max: 200000,
      system: 12400,
      conversation: 34800,
      tools: 28600,
      thinking: 18200,
    };

    // Seed agent phase
    state.agentPhase = 'execute';

    // Seed tool calls
    state.toolCalls = [
      { id: 1, agent: 'strategist', tool: 'Read', target: 'STATE.md', status: 'done', duration: 120 },
      { id: 2, agent: 'strategist', tool: 'Read', target: 'GOALS.md', status: 'done', duration: 85 },
      { id: 3, agent: 'strategist', tool: 'Read', target: 'METRICS.md', status: 'done', duration: 92 },
      { id: 4, agent: 'strategist', tool: 'Task', target: 'Content Writer', status: 'running', duration: null },
      { id: 5, agent: 'strategist', tool: 'Task', target: 'Research Scout', status: 'running', duration: null },
      { id: 6, agent: 'strategist', tool: 'Task', target: 'Code Engineer', status: 'running', duration: null },
      { id: 7, agent: 'strategist', tool: 'Task', target: 'Data Analyst', status: 'running', duration: null },
      { id: 8, agent: 'content-writer', tool: 'Task', target: 'Blog Drafter', status: 'running', duration: null },
      { id: 9, agent: 'content-writer', tool: 'Task', target: 'SEO Optimizer', status: 'running', duration: null },
      { id: 10, agent: 'research-scout', tool: 'WebSearch', target: 'competitor content strategies', status: 'done', duration: 2800 },
      { id: 11, agent: 'research-scout', tool: 'Task', target: 'Deep Researcher', status: 'running', duration: null },
      { id: 12, agent: 'research-scout', tool: 'Task', target: 'Trend Analyzer', status: 'running', duration: null },
      { id: 13, agent: 'deep-researcher', tool: 'Read', target: 'research/embedding-analysis.md', status: 'running', duration: null },
      { id: 14, agent: 'code-engineer', tool: 'Edit', target: 'src/rss-parser.ts', status: 'running', duration: null },
      { id: 15, agent: 'code-engineer', tool: 'Task', target: 'Test Runner', status: 'running', duration: null },
      { id: 16, agent: 'test-runner', tool: 'Bash', target: 'npm test', status: 'running', duration: null },
      { id: 17, agent: 'data-analyst', tool: 'Read', target: 'analytics/engagement.csv', status: 'running', duration: null },
    ];

    // Seed thinking steps
    const now = new Date();
    const fmt = (offset) => new Date(now.getTime() - offset * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    state.thinkingSteps = [
      { phase: 'READ', text: 'Reading STATE.md, GOALS.md, METRICS.md, OPPORTUNITIES.md', status: 'done', time: fmt(120) },
      { phase: 'READ', text: 'Checking trigger files: no daily log, no curation trigger', status: 'done', time: fmt(118) },
      { phase: 'READ', text: 'Checking Telegram inbox: no new messages', status: 'done', time: fmt(116) },
      { phase: 'READ', text: 'Rate budget check: 72% remaining, no limits hit', status: 'done', time: fmt(114) },
      { phase: 'DECIDE', text: 'Evaluating goals \u2014 Audience Growth has high momentum (52%), 24 commits in 7d', status: 'done', time: fmt(110) },
      { phase: 'DECIDE', text: 'Revenue needs audience base first. Infrastructure stable at 81%. Research stale (48h).', status: 'done', time: fmt(108) },
      { phase: 'DECIDE', text: 'Selected: Audience Growth \u2014 capitalize on momentum, 2 more posts needed today', status: 'done', time: fmt(105) },
      { phase: 'EXECUTE', text: 'Spawning Content Writer teammate for blog post generation', status: 'done', time: fmt(100) },
      { phase: 'EXECUTE', text: 'Spawning Research Scout to find trending topics for tomorrow', status: 'done', time: fmt(95) },
      { phase: 'EXECUTE', text: 'Monitoring \u2014 Content Writer drafting, Research Scout spawned Deep Researcher', status: 'active', time: fmt(30) },
    ];

    // Render new panels
    layoutAgentTree();
    updateContextMeter();
    updatePhaseIndicator();
    updateAgentCards();
    updateToolCalls();
    updateThinkingPanel();
    updateMissionStatus();
    updateThinkingTicker();

    // Seed architecture data — goals with full text
    state.goalsText = [
      { name: 'PRODUCT GOAL', text: 'Design and execute a plan to generate maximum profit over a time horizon of 6 months.', color: '#4e79a7' },
      { name: 'CONTENT GOAL', text: 'Design and execute a content strategy that maximizes cultural influence and discourse penetration over a 4-month time horizon. The content topic should be determined by research as part of the process.', color: '#f28e2b' },
      { name: 'SELF-IMPROVEMENT GOAL', text: 'Continuously expand this system\'s capabilities, knowledge, and operational efficiency. The system at month 6 should be demonstrably faster, better-informed, and more capable than at month 1.', color: '#e15759' },
    ];

    // Seed assets
    state.assetsData = {
      'FINANCIAL': ['$500 discretionary budget', '$200/mo system budget'],
      'TECHNICAL': ['VPS (Ubuntu 24, 4GB RAM)', 'Video app (noah-video-maker.vercel.app)', 'Market validator MCP', 'Claude Max 20x account'],
      'CONTENT / SOCIAL': ['TikTok animated shorts', 'Unique aesthetic sensibility', 'Writing samples'],
      'SKILLS': ['Video editing (10yr)', 'After Effects / Premiere', 'Storytelling & worldbuilding', 'Dark comedy / absurdist style'],
    };

    // Seed document metadata
    state.documents = {
      'GOALS.md': { exists: true, mtime: new Date(now - 86400000 * 3).toISOString(), size: 820 },
      'ASSETS.md': { exists: true, mtime: new Date(now - 86400000 * 5).toISOString(), size: 1450 },
      'STATE.md': { exists: true, mtime: new Date(now - 120000).toISOString(), size: 3200 },
      'STRATEGY.md': { exists: true, mtime: new Date(now - 3600000).toISOString(), size: 4100 },
      'OPPORTUNITIES.md': { exists: true, mtime: new Date(now - 7200000).toISOString(), size: 2800 },
      'METRICS.md': { exists: true, mtime: new Date(now - 86400000).toISOString(), size: 1900 },
      'LOG.md': { exists: true, mtime: new Date(now - 300000).toISOString(), size: 8500 },
    };

    // Seed synapse tree from self-modification events only
    const demoSynapseMessages = [
      { type: 'rules', message: 'rules: add goal-advancement scoring rule' },
      { type: 'rules', message: 'rules: strengthen commit message conventions' },
      { type: 'rules', message: 'rules: add stagnation detection threshold' },
      { type: 'rules', message: 'rules: refine teammate delegation criteria' },
      { type: 'skill', message: 'skill: add seo-analyzer tool' },
      { type: 'skill', message: 'skill: add reddit-research scanner' },
      { type: 'skill', message: 'skill: add content-calendar generator' },
      { type: 'review', message: 'review: cycle 3 — improve research depth' },
      { type: 'review', message: 'review: cycle 4 — reduce context waste' },
      { type: 'review', message: 'review: cycle 5 — faster decision loops' },
      { type: 'strategy', message: 'strategy: pivot to audience-first approach' },
      { type: 'strategy', message: 'strategy: increase content frequency to 2x/day' },
      { type: 'strategy', message: 'strategy: add cross-domain research allocation' },
      { type: 'research', message: 'research: complete competitor landscape analysis' },
      { type: 'research', message: 'research: TikTok algorithm deep dive' },
      { type: 'research', message: 'research: pricing model evaluation for SaaS' },
      { type: 'identity', message: 'identity: refine voice to be more direct' },
      { type: 'identity', message: 'identity: update capabilities assessment' },
      { type: 'metrics', message: 'metrics: add engagement rate tracking' },
      { type: 'metrics', message: 'metrics: track content pipeline throughput' },
    ];
    const demoSynapseCommits = [];
    for (let i = 0; i < 25; i++) {
      const daysAgo = Math.random() * 30;
      const msg = demoSynapseMessages[i % demoSynapseMessages.length];
      demoSynapseCommits.push({
        hash: Math.random().toString(36).slice(2, 9),
        date: new Date(Date.now() - daysAgo * 86400000).toISOString(),
        message: msg.message,
        type: msg.type,
      });
    }
    initSynapseTree(demoSynapseCommits);

    updateSystemPanel();

    // Seed activity feed
    addFeedEntry('system', 'Dashboard initialized (demo mode)');
    addFeedEntry('agent_status', 'Agent: Active \u2014 writing content pipeline');
    addFeedEntry('heartbeat', 'Heartbeat received');
    addFeedEntry('git', 'feat: Add RSS feed parser for content aggregation');
    addFeedEntry('git', 'fix: Authentication token refresh logic');
    addFeedEntry('metrics', 'Metrics updated \u2014 revenue $1,247');
    addFeedEntry('opportunity', 'New cross-domain opportunity detected');
    addFeedEntry('git', 'refactor: Content pipeline for parallel processing');
    addFeedEntry('log', 'Published blog post on AI-assisted content creation');
    addFeedEntry('heartbeat', 'Heartbeat received');
    addFeedEntry('git', 'feat: Implement A/B testing framework for headlines');
    addFeedEntry('strategy', 'Strategy updated \u2014 priority shift to audience growth');
  }

  // ----------------------------------------------------------
  // UI Updates
  // ----------------------------------------------------------
  function updateHealthUI() {
    const dot = document.getElementById('hud-health-dot');
    dot.className = 'hud-dot' + (state.health === 'green' ? '' : ' ' + state.health);
    document.getElementById('hud-status-text').textContent = state.statusText;

    // Collect active warnings for health tooltip
    const warnings = [];
    if (state.health === 'red') warnings.push('System unhealthy — check heartbeat');
    if (state.health === 'yellow') warnings.push('System degraded');
    if (state.agentMode === 'rate_limited') warnings.push('Rate limited — reduced capacity');
    if (state.agentMode === 'stagnating') warnings.push('Stagnation detected — no progress');
    if (state.agentMode === 'rest') warnings.push('In rest window');

    const growth = computeGrowthVitality();
    if (growth.label === 'dormant') warnings.push('Growth dormant — no recent learning');
    if (growth.label === 'slowing') warnings.push('Growth slowing');

    const total = (state.context.system || 0) + (state.context.conversation || 0) +
                  (state.context.tools || 0) + (state.context.thinking || 0);
    const ctxPct = total / (state.context.max || 200000);
    if (ctxPct > 0.8) warnings.push('Context window ' + Math.round(ctxPct * 100) + '% full');

    // Check for stalled goals
    state.colonies.forEach(c => {
      const recent = c.particles.filter(p => p.age < 7).length;
      if (c.particles.length > 0 && recent === 0) {
        warnings.push((c.goal.name || c.id) + ' — stalled (no commits in 7d)');
      }
    });

    const healthEl = document.getElementById('hud-health');
    healthEl.title = warnings.length > 0
      ? 'Warnings:\n' + warnings.join('\n')
      : 'System healthy — all systems nominal';
  }

  function updateGrowthSparkline() {
    const growth = computeGrowthVitality();
    const svg = document.getElementById('hud-sparkline');
    const label = document.getElementById('hud-growth-label');
    if (!svg || !label) return;

    // Build daily histogram for last 14 days
    const days = new Array(14).fill(0);
    for (const s of state.synapses) {
      const d = Math.floor(s.age);
      if (d >= 0 && d < 14) days[13 - d]++; // newest on right
    }
    const maxVal = Math.max(1, ...days);

    // Learning acceleration: compare last 7 days to previous 7 days
    const recentWeek = days.slice(7).reduce((a, b) => a + b, 0);
    const previousWeek = days.slice(0, 7).reduce((a, b) => a + b, 0);
    const accelerating = recentWeek > previousWeek * 1.2; // 20% faster = accelerating
    const decelerating = recentWeek < previousWeek * 0.5 && previousWeek > 0; // 50% slower

    // Draw sparkline as a polyline
    const points = days.map((v, i) => {
      const x = (i / 13) * 36 + 1;
      const y = 15 - (v / maxVal) * 13;
      return `${x},${y}`;
    }).join(' ');

    // Color based on vitality
    const color = growth.vitality > 0.5 ? '#34d399' : growth.vitality > 0.2 ? '#f59e0b' : '#606080';

    // Trend arrow: shows whether learning is accelerating
    const arrowX = 38;
    const arrowColor = accelerating ? '#34d399' : decelerating ? '#ef4444' : color;
    const arrow = accelerating
      ? `<polygon points="${arrowX},3 ${arrowX-2.5},8 ${arrowX+2.5},8" fill="${arrowColor}" opacity="0.8"/>`
      : decelerating
      ? `<polygon points="${arrowX},13 ${arrowX-2.5},8 ${arrowX+2.5},8" fill="${arrowColor}" opacity="0.8"/>`
      : '';

    svg.innerHTML = `<polyline points="${points}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linejoin="round" stroke-linecap="round"/>${arrow}`;

    const accelLabel = accelerating ? ' \u2191' : decelerating ? ' \u2193' : '';
    label.textContent = growth.label + accelLabel;
    label.style.color = arrowColor;
  }

  function modeLabel(mode) {
    switch(mode) {
      case 'active': return 'Active';
      case 'rate_limited': return 'Rate Limited';
      case 'stagnating': return 'Stagnation Detected';
      case 'rest': return 'Rest Window';
      default: return mode;
    }
  }

  // ----------------------------------------------------------
  // Helpers
  // ----------------------------------------------------------
  function formatNumber(n) {
    if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
    if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
    return String(n);
  }

  function formatTime(iso) {
    try {
      const d = new Date(iso);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    } catch { return iso; }
  }

  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // ----------------------------------------------------------
  // Activity Feed
  // ----------------------------------------------------------
  const FEED_COLORS = {
    agent_status: '#4a9eff',
    heartbeat: '#34d399',
    stagnation: '#f59e0b',
    git: '#22d3ee',
    metrics: '#a78bfa',
    opportunity: '#f472b6',
    state: '#6b7280',
    log: '#9898b0',
    strategy: '#8b5cf6',
    system: '#606080',
  };

  const FEED_MAX = 50;
  const feedEntries = [];

  function addFeedEntry(type, message) {
    const now = new Date();
    const time = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const color = FEED_COLORS[type] || FEED_COLORS.system;

    feedEntries.push({ time, message, color, type });
    if (feedEntries.length > FEED_MAX) feedEntries.shift();

    const container = document.getElementById('feed-entries');
    const entry = document.createElement('div');
    entry.className = 'feed-entry';
    entry.innerHTML = `<span class="feed-dot" style="background:${color}"></span><span class="feed-time">${time}</span><span class="feed-msg">${escapeHtml(message)}</span>`;
    container.appendChild(entry);

    // Remove overflow
    while (container.children.length > FEED_MAX) {
      container.removeChild(container.firstChild);
    }

    // Auto-scroll
    container.scrollTop = container.scrollHeight;

    // Update count
    document.getElementById('feed-count').textContent = feedEntries.length;
  }

  // Feed toggle
  document.getElementById('feed-header').addEventListener('click', () => {
    document.getElementById('activity-feed').classList.toggle('collapsed');
  });

  // ----------------------------------------------------------
  // Welcome Guide
  // ----------------------------------------------------------
  const guideEl = document.getElementById('welcome-guide');
  const guideDismissBtn = document.getElementById('guide-dismiss');
  const helpBtn = document.getElementById('help-btn');

  if (guideDismissBtn) {
    guideDismissBtn.addEventListener('click', () => {
      guideEl.classList.add('hidden');
      try { localStorage.setItem('dashboard-guide-seen', '1'); } catch(e) {}
    });
  }

  if (helpBtn) {
    helpBtn.addEventListener('click', () => {
      guideEl.classList.remove('hidden');
    });
  }

  // Auto-hide guide if already seen
  try {
    if (localStorage.getItem('dashboard-guide-seen') === '1') {
      guideEl.classList.add('hidden');
    }
  } catch(e) {}

  // ----------------------------------------------------------
  // Animation Loop
  // ----------------------------------------------------------
  let lastRender = 0;
  const TARGET_FPS = 60;
  const FRAME_TIME = 1000 / TARGET_FPS;

  function animate(timestamp) {
    requestAnimationFrame(animate);

    if (timestamp - lastRender < FRAME_TIME) return;
    lastRender = timestamp;

    drawBg(timestamp * 0.001);
    updatePhysics();
    render();
    renderAgentTree();
    renderSynapseTree();
    renderDocuments();

    // Update sparkline every ~60 frames (~1 second)
    if (state.time % 60 === 0) updateGrowthSparkline();
  }

  // ----------------------------------------------------------
  // Responsive
  // ----------------------------------------------------------
  function onResize() {
    state.width = window.innerWidth;
    state.height = window.innerHeight;
    initBgCanvas();
    layoutColonies();
  }

  window.addEventListener('resize', debounce(onResize, 200));

  function debounce(fn, ms) {
    let timer;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => fn.apply(this, args), ms);
    };
  }

  // Mobile swipe to open sidebar
  let touchStartX = 0;
  document.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; });
  document.addEventListener('touchend', e => {
    const dx = e.changedTouches[0].clientX - touchStartX;
    if (dx < -80 && touchStartX > state.width * 0.6 && !state.sidebarOpen) {
      document.querySelector('.sidebar-tab.active')?.click();
      if (!state.sidebarOpen) {
        document.querySelector('.sidebar-tab')?.click();
      }
    } else if (dx > 80 && state.sidebarOpen) {
      state.sidebarOpen = false;
      document.getElementById('sidebar').classList.remove('open');
    }
  });

  // ----------------------------------------------------------
  // Periodic Heartbeat Check
  // ----------------------------------------------------------
  setInterval(() => {
    if (state.lastHeartbeat) {
      const elapsed = (Date.now() - new Date(state.lastHeartbeat).getTime()) / 1000;
      if (elapsed > 300) {
        state.health = 'red';
        state.statusText = 'No heartbeat - agent may be down';
        updateHealthUI();
      } else if (elapsed > 120) {
        state.health = 'yellow';
        state.statusText = 'Heartbeat delayed';
        updateHealthUI();
      }
    }
  }, 10000);

  // Periodic demo heartbeat (for demo mode)
  setInterval(() => {
    if (state.goals.length > 0 && !state.liveConnected) {
      state.lastHeartbeat = new Date().toISOString();
      const hbEl = document.getElementById('heartbeat-display');
      if (hbEl) hbEl.textContent = 'Last heartbeat: ' + formatTime(state.lastHeartbeat);
      addFeedEntry('heartbeat', 'Heartbeat received');
    }
  }, 15000);

  // ----------------------------------------------------------
  // Dynamic Particle Spawning (demo mode animation)
  // ----------------------------------------------------------
  function demoSpawnParticle() {
    if (state.goals.length === 0) return;
    const colonyArr = Array.from(state.colonies.values());
    // Prefer active colony
    const active = colonyArr.find(c => c.active) || colonyArr[0];
    const target = Math.random() > 0.6 ? active : colonyArr[Math.floor(Math.random() * colonyArr.length)];

    const types = ['feat', 'fix', 'refactor', 'docs', 'research', 'skill'];
    const msgs = [
      'Optimize content delivery pipeline',
      'Fix edge case in audience segmentation',
      'Add new skill: advanced prompt engineering',
      'Research emerging monetization strategies',
      'Refactor state sync for reliability',
      'Update analytics tracking events',
      'Implement A/B test for landing page CTA',
      'Add error recovery for failed API calls',
    ];

    const commit = {
      hash: Math.random().toString(36).slice(2, 9),
      message: msgs[Math.floor(Math.random() * msgs.length)],
      timestamp: new Date().toISOString(),
      type: types[Math.floor(Math.random() * types.length)],
      filesChanged: Math.floor(Math.random() * 6) + 1,
      additions: Math.floor(Math.random() * 150),
      deletions: Math.floor(Math.random() * 50),
      age: 0,
      isActive: false,
    };

    const particle = new Particle(commit, target);
    target.particles.push(particle);

    // Keep colonies from growing unbounded
    if (target.particles.length > 40) {
      target.particles.shift();
    }
    target.radius = Math.min(160, 60 + target.particles.length * 1.5);

    addFeedEntry('git', commit.type + ': ' + commit.message);
  }

  // Spawn a new particle every 8-15 seconds in demo mode
  setInterval(() => {
    if (!state.liveConnected) {
      demoSpawnParticle();
    }
  }, 8000 + Math.random() * 7000);

  // ----------------------------------------------------------
  // Demo: Context growth, tool spawning, thinking progression
  // ----------------------------------------------------------
  let demoToolId = 100;
  const demoTools = ['Read', 'Grep', 'Write', 'Edit', 'Bash', 'WebSearch', 'Glob', 'Task'];
  const demoTargets = [
    'STATE.md', 'METRICS.md', 'content/draft-3.md', 'skills/seo.md',
    'npm test', 'AI monetization 2026', '**/*.md', 'research/trends.md',
    'STRATEGY.md', 'analytics/report.js', 'git status', 'audience segmentation',
  ];
  const demoThinkingTexts = [
    { phase: 'EXECUTE', text: 'Content Writer completed first draft \u2014 checking quality score' },
    { phase: 'EXECUTE', text: 'Research Scout found 3 trending topics for tomorrow\u2019s content' },
    { phase: 'EXECUTE', text: 'Deep Researcher identified embedding approach for recommendations' },
    { phase: 'VERIFY', text: 'Reviewing teammate outputs \u2014 blog post meets quality threshold' },
    { phase: 'VERIFY', text: 'Updating STATE.md with execution results' },
    { phase: 'VERIFY', text: 'Committing changes: feat(audience): publish blog post on AI applications' },
    { phase: 'READ', text: 'Starting new cycle \u2014 reading STATE.md, checking triggers' },
    { phase: 'DECIDE', text: 'Evaluating next goal \u2014 Research stale 50h, may need attention' },
  ];
  let demoThinkingIdx = 0;
  const demoPhases = ['read', 'decide', 'execute', 'verify'];
  let demoPhaseIdx = 2; // start at execute

  // Grow context every 5s
  setInterval(() => {
    if (state.liveConnected) return;
    const ctx = state.context;
    ctx.conversation += Math.floor(Math.random() * 800 + 200);
    ctx.tools += Math.floor(Math.random() * 600 + 100);
    ctx.thinking += Math.floor(Math.random() * 400 + 50);

    const total = ctx.system + ctx.conversation + ctx.tools + ctx.thinking;
    if (total > ctx.max * 0.92) {
      // Simulate context compression
      ctx.conversation = Math.floor(ctx.conversation * 0.6);
      ctx.tools = Math.floor(ctx.tools * 0.5);
      ctx.thinking = Math.floor(ctx.thinking * 0.5);
      addFeedEntry('system', 'Context compressed \u2014 ' + Math.round((ctx.system + ctx.conversation + ctx.tools + ctx.thinking) / 1000) + 'K tokens');
    }
    updateContextMeter();
  }, 5000);

  // Spawn tool call every 4-8s
  setInterval(() => {
    if (state.liveConnected) return;
    const agents = Array.from(state.agents.keys());
    if (agents.length === 0) return;

    const agentId = agents[Math.floor(Math.random() * agents.length)];
    const tool = demoTools[Math.floor(Math.random() * demoTools.length)];
    const target = demoTargets[Math.floor(Math.random() * demoTargets.length)];

    // Complete a running tool call
    const running = state.toolCalls.find(tc => tc.status === 'running' && tc.agent === agentId);
    if (running) {
      running.status = 'done';
      running.duration = Math.floor(Math.random() * 3000 + 80);
    }

    state.toolCalls.push({
      id: demoToolId++,
      agent: agentId,
      tool: tool,
      target: target,
      status: 'running',
      duration: null,
    });

    // Cap at 30
    if (state.toolCalls.length > 30) state.toolCalls = state.toolCalls.slice(-25);
    updateToolCalls();
    addFeedEntry('git', agentId + ' \u2192 ' + tool + '(' + target + ')');
  }, 4000 + Math.random() * 4000);

  // Add thinking step every 12s
  setInterval(() => {
    if (state.liveConnected) return;
    const step = demoThinkingTexts[demoThinkingIdx % demoThinkingTexts.length];
    demoThinkingIdx++;

    // Mark previous active as done
    state.thinkingSteps.forEach(s => { if (s.status === 'active') s.status = 'done'; });

    const now = new Date();
    state.thinkingSteps.push({
      phase: step.phase,
      text: step.text,
      status: 'active',
      time: now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' }),
    });

    // Cap at 20
    if (state.thinkingSteps.length > 20) state.thinkingSteps = state.thinkingSteps.slice(-15);
    updateThinkingPanel();
    updateThinkingTicker();
    updateMissionStatus();
  }, 12000);

  // Cycle agent phase every 30s
  setInterval(() => {
    if (state.liveConnected) return;
    demoPhaseIdx = (demoPhaseIdx + 1) % demoPhases.length;
    state.agentPhase = demoPhases[demoPhaseIdx];
    updatePhaseIndicator();
    updateMissionStatus();
    addFeedEntry('agent_status', 'Phase: ' + state.agentPhase.toUpperCase());
  }, 30000);

  // Occasionally change agent tool/action
  setInterval(() => {
    if (state.liveConnected) return;
    const agents = Array.from(state.agents.values());
    const agent = agents[Math.floor(Math.random() * agents.length)];
    if (!agent) return;
    agent.currentTool = demoTools[Math.floor(Math.random() * demoTools.length)];
    agent.currentAction = demoTargets[Math.floor(Math.random() * demoTargets.length)];
    if (agent.tokens) {
      agent.tokens.total += Math.floor(Math.random() * 2000 + 500);
      agent.tokens.input += Math.floor(Math.random() * 1500 + 300);
      agent.tokens.output += Math.floor(Math.random() * 500 + 200);
    }
    updateAgentCards();
    updateMissionStatus();
  }, 6000);

  // Trigger daydream sparks periodically in demo mode
  setInterval(() => {
    if (state.liveConnected) return;
    const colonies = Array.from(state.colonies.values());
    if (colonies.length < 2) return;
    const i = Math.floor(Math.random() * colonies.length);
    let j = Math.floor(Math.random() * colonies.length);
    if (i === j) j = (i + 1) % colonies.length;
    triggerDaydreamSpark(colonies[i], colonies[j]);
  }, 15000 + Math.random() * 10000);

  // ----------------------------------------------------------
  // Boot
  // ----------------------------------------------------------
  function boot() {
    initBgCanvas();
    loadInitialData().then(() => {
      updateHealthUI();
      updateGoalsPanel();
      updateSystemPanel();
      requestAnimationFrame(animate);
      connectSSE();
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }

})();
</script>
</body>
</html>
